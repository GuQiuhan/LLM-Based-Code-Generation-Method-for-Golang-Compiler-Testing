// Code generated by cmd/cgo; DO NOT EDIT.

//line /bigdata/qiuhan/codet5/usage/goroot/misc/cgo/test/test.go:1:1
// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test cases for cgo.
// Both the import "C" prologue and the main file are sorted by issue number.
// This file contains C definitions (not just declarations)
// and so it must NOT contain any //export directives on Go functions.
// See testx.go for exports.

package cgotest; import _cgo_unsafe "unsafe"

/*
#include <complex.h>
#include <math.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <errno.h>
#cgo LDFLAGS: -lm

#ifndef WIN32
#include <pthread.h>
#include <signal.h>
#endif

// alignment tests

typedef unsigned char Uint8;
typedef unsigned short Uint16;

typedef enum {
 MOD1 = 0x0000,
 MODX = 0x8000
} SDLMod;

typedef enum {
 A1 = 1,
 B1 = 322,
 SDLK_LAST
} SDLKey;

typedef struct SDL_keysym {
	Uint8 scancode;
	SDLKey sym;
	SDLMod mod;
	Uint16 unicode;
} SDL_keysym;

typedef struct SDL_KeyboardEvent {
	Uint8 typ;
	Uint8 which;
	Uint8 state;
	SDL_keysym keysym;
} SDL_KeyboardEvent;

void makeEvent(SDL_KeyboardEvent *event) {
 unsigned char *p;
 int i;

 p = (unsigned char*)event;
 for (i=0; i<sizeof *event; i++) {
   p[i] = i;
 }
}

int same(SDL_KeyboardEvent* e, Uint8 typ, Uint8 which, Uint8 state, Uint8 scan, SDLKey sym, SDLMod mod, Uint16 uni) {
  return e->typ == typ && e->which == which && e->state == state && e->keysym.scancode == scan && e->keysym.sym == sym && e->keysym.mod == mod && e->keysym.unicode == uni;
}

void cTest(SDL_KeyboardEvent *event) {
 printf("C: %#x %#x %#x %#x %#x %#x %#x\n", event->typ, event->which, event->state,
   event->keysym.scancode, event->keysym.sym, event->keysym.mod, event->keysym.unicode);
 fflush(stdout);
}

// api

const char *greeting = "hello, world";

// basic test cases

#define SHIFT(x, y)  ((x)<<(y))
#define KILO SHIFT(1, 10)
#define UINT32VAL 0xc008427bU

enum E {
	Enum1 = 1,
	Enum2 = 2,
};

typedef unsigned char cgo_uuid_t[20];

void uuid_generate(cgo_uuid_t x) {
	x[0] = 0;
}

struct S {
	int x;
};

const char *cstr = "abcefghijklmnopqrstuvwxyzABCEFGHIJKLMNOPQRSTUVWXYZ1234567890";

extern enum E myConstFunc(struct S* const ctx, int const id, struct S **const filter);

enum E myConstFunc(struct S *const ctx, int const id, struct S **const filter) { return 0; }

int add(int x, int y) {
	return x+y;
};

// Following mimicks vulkan complex definitions for benchmarking cgocheck overhead.

typedef uint32_t VkFlags;
typedef VkFlags  VkDeviceQueueCreateFlags;
typedef uint32_t VkStructureType;

typedef struct VkDeviceQueueCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    const float*                pQueuePriorities;
} VkDeviceQueueCreateInfo;

typedef struct VkPhysicalDeviceFeatures {
    uint32_t bools[56];
} VkPhysicalDeviceFeatures;

typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkFlags                            flags;
    uint32_t                           queueCreateInfoCount;
    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    const char* const*                 ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    const char* const*                 ppEnabledExtensionNames;
    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo;

void handleComplexPointer(VkDeviceCreateInfo *a0) {}
void handleComplexPointer8(
	VkDeviceCreateInfo *a0, VkDeviceCreateInfo *a1, VkDeviceCreateInfo *a2, VkDeviceCreateInfo *a3,
	VkDeviceCreateInfo *a4, VkDeviceCreateInfo *a5, VkDeviceCreateInfo *a6, VkDeviceCreateInfo *a7
) {}

// complex alignment

struct {
	float x;
	_Complex float y;
} cplxAlign = { 3.14, 2.17 };

// constants and pointer checking

#define CheckConstVal 0

typedef struct {
	int *p;
} CheckConstStruct;

static void CheckConstFunc(CheckConstStruct *p, int e) {}

// duplicate symbol

int base_symbol = 0;
#define alias_one base_symbol
#define alias_two base_symbol

// function pointer variables

typedef int (*intFunc) ();

int
bridge_int_func(intFunc f)
{
	return f();
}

int fortytwo()
{
	return 42;
}

// issue 1222
typedef union {
	long align;
} xxpthread_mutex_t;
struct ibv_async_event {
	union {
		int x;
	} element;
};
struct ibv_context {
	xxpthread_mutex_t mutex;
};

// issue 1635
// Mac OS X's gcc will generate scattered relocation 2/1 for
// this function on Darwin/386, and 8l couldn't handle it.
// this example is in issue 1635
void scatter() {
	void *p = scatter;
	printf("scatter = %p\n", p);
}

// Adding this explicit extern declaration makes this a test for
// https://gcc.gnu.org/PR68072 aka https://golang.org/issue/13344 .
// It used to cause a cgo error when building with GCC 6.
extern int hola;

// this example is in issue 3253
int hola = 0;
int testHola() { return hola; }

// issue 3250
#ifdef WIN32
void testSendSIG() {}
#else
static void *thread(void *p) {
	const int M = 100;
	int i;
	(void)p;
	for (i = 0; i < M; i++) {
		pthread_kill(pthread_self(), SIGCHLD);
		usleep(rand() % 20 + 5);
	}
	return NULL;
}
void testSendSIG() {
	const int N = 20;
	int i;
	pthread_t tid[N];
	for (i = 0; i < N; i++) {
		usleep(rand() % 200 + 100);
		pthread_create(&tid[i], 0, thread, NULL);
	}
	for (i = 0; i < N; i++)
		pthread_join(tid[i], 0);
}
#endif

// issue 3261
// libgcc on ARM might be compiled as thumb code, but our 5l
// can't handle that, so we have to disable this test on arm.
#ifdef __ARMEL__
int vabs(int x) {
	puts("testLibgcc is disabled on ARM because 5l cannot handle thumb library.");
	return (x < 0) ? -x : x;
}
#elif defined(__arm64__) && defined(__clang__)
int vabs(int x) {
	puts("testLibgcc is disabled on ARM64 with clang due to lack of libgcc.");
	return (x < 0) ? -x : x;
}
#else
int __absvsi2(int); // dummy prototype for libgcc function
// we shouldn't name the function abs, as gcc might use
// the builtin one.
int vabs(int x) { return __absvsi2(x); }
#endif


// issue 3729
// access errno from void C function
const char _expA = 0x42;
const float _expB = 3.14159;
const short _expC = 0x55aa;
const int _expD = 0xdeadbeef;

#ifdef WIN32
void g(void) {}
void g2(int x, char a, float b, short c, int d) {}
#else

void g(void) {
	errno = E2BIG;
}

// try to pass some non-trivial arguments to function g2
void g2(int x, char a, float b, short c, int d) {
	if (a == _expA && b == _expB && c == _expC && d == _expD)
		errno = x;
	else
		errno = -1;
}
#endif

// issue 3945
// Test that cgo reserves enough stack space during cgo call.
// See https://golang.org/issue/3945 for details.
void say() {
	printf("%s from C\n", "hello");
}

// issue 4054 part 1 - other half in testx.go

typedef enum {
	A = 0,
	B,
	C,
	D,
	E,
	F,
	G,
	H,
	II,
	J,
} issue4054a;

// issue 4339
// We've historically permitted #include <>, so test it here.  Issue 29333.
// Also see issue 41059.
#include <issue4339.h>

// issue 4417
// cmd/cgo: bool alignment/padding issue.
// bool alignment is wrong and causing wrong arguments when calling functions.
static int c_bool(bool a, bool b, int c, bool d, bool e)  {
   return c;
}

// issue 4857
#cgo CFLAGS: -Werror
const struct { int a; } *issue4857() { return (void *)0; }

// issue 5224
// Test that the #cgo CFLAGS directive works,
// with and without platform filters.
#cgo CFLAGS: -DCOMMON_VALUE=123
#cgo windows CFLAGS: -DIS_WINDOWS=1
#cgo !windows CFLAGS: -DIS_WINDOWS=0
int common = COMMON_VALUE;
int is_windows = IS_WINDOWS;

// issue 5227
// linker incorrectly treats common symbols and
// leaves them undefined.

typedef struct {
        int Count;
} Fontinfo;

Fontinfo SansTypeface;

extern void init();

Fontinfo loadfont() {
        Fontinfo f = {0};
        return f;
}

void init() {
        SansTypeface = loadfont();
}

// issue 5242
// Cgo incorrectly computed the alignment of structs
// with no Go accessible fields as 0, and then panicked on
// modulo-by-zero computations.

// issue 50987
// disable arm64 GCC warnings
#cgo CFLAGS: -Wno-psabi -Wno-unknown-warning-option

typedef struct {
} foo;

typedef struct {
	int x : 1;
} bar;

int issue5242(foo f, bar b) {
	return 5242;
}

// issue 5337
// Verify that we can withstand SIGPROF received on foreign threads

#ifdef WIN32
void test5337() {}
#else
static void *thread1(void *p) {
	(void)p;
	pthread_kill(pthread_self(), SIGPROF);
	return NULL;
}
void test5337() {
	pthread_t tid;
	pthread_create(&tid, 0, thread1, NULL);
	pthread_join(tid, 0);
}
#endif

// issue 5603

const long long issue5603exp = 0x12345678;
long long issue5603foo0() { return issue5603exp; }
long long issue5603foo1(void *p) { return issue5603exp; }
long long issue5603foo2(void *p, void *q) { return issue5603exp; }
long long issue5603foo3(void *p, void *q, void *r) { return issue5603exp; }
long long issue5603foo4(void *p, void *q, void *r, void *s) { return issue5603exp; }

// issue 5740

int test5740a(void), test5740b(void);

// issue 5986
static void output5986()
{
    int current_row = 0, row_count = 0;
    double sum_squares = 0;
    double d;
    do {
        if (current_row == 10) {
            current_row = 0;
        }
        ++row_count;
    }
    while (current_row++ != 1);
    d =  sqrt(sum_squares / row_count);
    printf("sqrt is: %g\n", d);
}

// issue 6128
// Test handling of #defined names in clang.
// NOTE: Must use hex, or else a shortcut for decimals
// in cgo avoids trying to pass this to clang.
#define X 0x1

// issue 6472
typedef struct
{
        struct
        {
            int x;
        } y[16];
} z;

// issue 6612
// Test new scheme for deciding whether C.name is an expression, type, constant.
// Clang silences some warnings when the name is a #defined macro, so test those too
// (even though we now use errors exclusively, not warnings).

void myfunc(void) {}
int myvar = 5;
const char *mytext = "abcdef";
typedef int mytype;
enum {
	myenum = 1234,
};

#define myfunc_def myfunc
#define myvar_def myvar
#define mytext_def mytext
#define mytype_def mytype
#define myenum_def myenum
#define myint_def 12345
#define myfloat_def 1.5
#define mystring_def "hello"

// issue 6907
char* Issue6907CopyString(_GoString_ s) {
	size_t n;
	const char *p;
	char *r;

	n = _GoStringLen(s);
	p = _GoStringPtr(s);
	r = malloc(n + 1);
	memmove(r, p, n);
	r[n] = '\0';
	return r;
}

// issue 7560
typedef struct {
	char x;
	long y;
} __attribute__((__packed__)) misaligned;

int
offset7560(void)
{
	return (uintptr_t)&((misaligned*)0)->y;
}

// issue 7786
// No runtime test, just make sure that typedef and struct/union/class are interchangeable at compile time.

struct test7786;
typedef struct test7786 typedef_test7786;
void f7786(struct test7786 *ctx) {}
void g7786(typedef_test7786 *ctx) {}

typedef struct body7786 typedef_body7786;
struct body7786 { int x; };
void b7786(struct body7786 *ctx) {}
void c7786(typedef_body7786 *ctx) {}

typedef union union7786 typedef_union7786;
void u7786(union union7786 *ctx) {}
void v7786(typedef_union7786 *ctx) {}

// issue 8092
// Test that linker defined symbols (e.g., text, data) don't
// conflict with C symbols.
char text[] = "text";
char data[] = "data";
char *ctext(void) { return text; }
char *cdata(void) { return data; }

// issue 8428
// Cgo inconsistently translated zero size arrays.

struct issue8428one {
	char b;
	char rest[];
};

struct issue8428two {
	void *p;
	char b;
	char rest[0];
	char pad;
};

struct issue8428three {
	char w[1][2][3][0];
	char x[2][3][0][1];
	char y[3][0][1][2];
	char z[0][1][2][3];
};

// issue 8331 part 1 - part 2 in testx.go
// A typedef of an unnamed struct is the same struct when
// #include'd twice.  No runtime test; just make sure it compiles.
#include "issue8331.h"

// issue 8368 and 8441
// Recursive struct definitions didn't work.
// No runtime test; just make sure it compiles.
typedef struct one one;
typedef struct two two;
struct one {
	two *x;
};
struct two {
	one *x;
};

// issue 8811

extern int issue8811Initialized;
extern void issue8811Init();

void issue8811Execute() {
	if(!issue8811Initialized)
		issue8811Init();
}

// issue 8945

typedef void (*PFunc8945)();
PFunc8945 func8945;

// issue 9557

struct issue9557_t {
  int a;
} test9557bar = { 42 };
struct issue9557_t *issue9557foo = &test9557bar;

// issue 10303
// Pointers passed to C were not marked as escaping (bug in cgo).

typedef int *intptr;

void setintstar(int *x) {
	*x = 1;
}

void setintptr(intptr x) {
	*x = 1;
}

void setvoidptr(void *x) {
	*(int*)x = 1;
}

typedef struct Struct Struct;
struct Struct {
	int *P;
};

void setstruct(Struct s) {
	*s.P = 1;
}

// issue 11925
// Structs with zero-length trailing fields are now padded by the Go compiler.

struct a11925 {
	int i;
	char a[0];
	char b[0];
};

struct b11925 {
	int i;
	char a[0];
	char b[];
};

// issue 12030
void issue12030conv(char *buf, double x) {
	sprintf(buf, "d=%g", x);
}

// issue 14838

int check_cbytes(char *b, size_t l) {
	int i;
	for (i = 0; i < l; i++) {
		if (b[i] != i) {
			return 0;
		}
	}
	return 1;
}

// issue 17065
// Test that C symbols larger than a page play nicely with the race detector.
int ii[65537];

// issue 17537
// The void* cast introduced by cgo to avoid problems
// with const/volatile qualifiers breaks C preprocessor macros that
// emulate functions.

typedef struct {
	int i;
} S17537;

int I17537(S17537 *p);

#define I17537(p) ((p)->i)

// Calling this function used to fail without the cast.
const int F17537(const char **p) {
	return **p;
}

// issue 17723
// API compatibility checks

typedef char *cstring_pointer;
static void cstring_pointer_fun(cstring_pointer dummy) { }
const char *api_hello = "hello!";

// Calling this function used to trigger an error from the C compiler
// (issue 18298).
void F18298(const void *const *p) {
}

// Test that conversions between typedefs work as they used to.
typedef const void *T18298_1;
struct S18298 { int i; };
typedef const struct S18298 *T18298_2;
void G18298(T18298_1 t) {
}

// issue 18126
// cgo check of void function returning errno.
void Issue18126C(void **p) {}

// issue 18720

#define HELLO "hello"
#define WORLD "world"
#define HELLO_WORLD HELLO "\000" WORLD

struct foo { char c; };
#define SIZE_OF(x) sizeof(x)
#define SIZE_OF_FOO SIZE_OF(struct foo)
#define VAR1 VAR
#define VAR var
int var = 5;

#define ADDR &var

#define CALL fn()
int fn(void) {
	return ++var;
}

// issue 20129

int issue20129 = 0;
typedef void issue20129Void;
issue20129Void issue20129Foo() {
	issue20129 = 1;
}
typedef issue20129Void issue20129Void2;
issue20129Void2 issue20129Bar() {
	issue20129 = 2;
}

// issue 20369
#define XUINT64_MAX        18446744073709551615ULL

// issue 21668
// Fail to guess the kind of the constant "x".
// No runtime test; just make sure it compiles.
const int x21668 = 42;

// issue 21708
#define CAST_TO_INT64 (int64_t)(-1)

// issue 21809
// Compile C `typedef` to go type aliases.

typedef long MySigned_t;
// tests alias-to-alias
typedef MySigned_t MySigned2_t;
long takes_long(long x) { return x * x; }
MySigned_t takes_typedef(MySigned_t x) { return x * x; }

// issue 22906

// It's going to be hard to include a whole real JVM to test this.
// So we'll simulate a really easy JVM using just the parts we need.
// This is the relevant part of jni.h.

struct _jobject;

typedef struct _jobject *jobject;
typedef jobject jclass;
typedef jobject jthrowable;
typedef jobject jstring;
typedef jobject jarray;
typedef jarray jbooleanArray;
typedef jarray jbyteArray;
typedef jarray jcharArray;
typedef jarray jshortArray;
typedef jarray jintArray;
typedef jarray jlongArray;
typedef jarray jfloatArray;
typedef jarray jdoubleArray;
typedef jarray jobjectArray;

typedef jobject jweak;

// Note: jvalue is already a non-pointer type due to it being a C union.

// issue 22958

typedef struct {
	unsigned long long f8  : 8;
	unsigned long long f16 : 16;
	unsigned long long f24 : 24;
	unsigned long long f32 : 32;
	unsigned long long f40 : 40;
	unsigned long long f48 : 48;
	unsigned long long f56 : 56;
	unsigned long long f64 : 64;
} issue22958Type;

// issue 23356
int a(void) { return 5; };
int r(void) { return 3; };

// issue 23720
typedef int *issue23720A;
typedef const int *issue23720B;
void issue23720F(issue23720B a) {}

// issue 24206
#if defined(__linux__) && defined(__x86_64__)
#include <sys/mman.h>
// Returns string with null byte at the last valid address
char* dangerousString1() {
	int pageSize = 4096;
	char *data = mmap(0, 2 * pageSize, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, 0, 0);
	mprotect(data + pageSize,pageSize,PROT_NONE);
	int start = pageSize - 123 - 1; // last 123 bytes of first page + 1 null byte
	int i = start;
	for (; i < pageSize; i++) {
	data[i] = 'x';
	}
	data[pageSize -1 ] = 0;
	return data+start;
}

char* dangerousString2() {
	int pageSize = 4096;
	char *data = mmap(0, 3 * pageSize, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, 0, 0);
	mprotect(data + 2 * pageSize,pageSize,PROT_NONE);
	int start = pageSize - 123 - 1; // last 123 bytes of first page + 1 null byte
	int i = start;
	for (; i < 2 * pageSize; i++) {
	data[i] = 'x';
	}
	data[2*pageSize -1 ] = 0;
	return data+start;
}
#else
char *dangerousString1() { return NULL; }
char *dangerousString2() { return NULL; }
#endif

// issue 26066
const unsigned long long int issue26066 = (const unsigned long long) -1;

// issue 26517
// Introduce two pointer types which are distinct, but have the same
// base type. Make sure that both of those pointer types get resolved
// correctly. Before the fix for 26517 if one of these pointer types
// was resolved before the other one was processed, the second one
// would never be resolved.
// Before this issue was fixed this test failed on Windows,
// where va_list expands to a named char* type.
typedef va_list TypeOne;
typedef char *TypeTwo;

// issue 28540

static void twoargs1(void *p, int n) {}
static void *twoargs2() { return 0; }
static int twoargs3(void * p) { return 0; }

// issue 28545
// Failed to add type conversion for negative constant.

static void issue28545F(char **p, int n, complex double a) {}

// issue 28772 part 1 - part 2 in testx.go
// Failed to add type conversion for Go constant set to C constant.
// No runtime test; just make sure it compiles.

#define issue28772Constant 1

// issue 28896
// cgo was incorrectly adding padding after a packed struct.
typedef struct {
	void *f1;
	uint32_t f2;
} __attribute__((__packed__)) innerPacked;

typedef struct {
	innerPacked g1;
	uint64_t g2;
} outerPacked;

typedef struct {
	void *f1;
	uint32_t f2;
} innerUnpacked;

typedef struct {
	innerUnpacked g1;
	uint64_t g2;
} outerUnpacked;

size_t offset(int x) {
	switch (x) {
	case 0:
		return offsetof(innerPacked, f2);
	case 1:
		return offsetof(outerPacked, g2);
	case 2:
		return offsetof(innerUnpacked, f2);
	case 3:
		return offsetof(outerUnpacked, g2);
	default:
		abort();
	}
}

// issue 29748

typedef struct { char **p; } S29748;
static int f29748(S29748 *p) { return 0; }

// issue 29781
// Error with newline inserted into constant expression.
// Compilation test only, nothing to run.

static void issue29781F(char **p, int n) {}
#define ISSUE29781C 0

// issue 31093
static uint16_t issue31093F(uint16_t v) { return v; }

// issue 32579
typedef struct S32579 { unsigned char data[1]; } S32579;

// issue 37033, cgo.Handle
extern void GoFunc37033(uintptr_t handle);
void cFunc37033(uintptr_t handle) { GoFunc37033(handle); }

// issue 38649
// Test that #define'd type aliases work.
#define netbsd_gid unsigned int

// issue 40494
// Inconsistent handling of tagged enum and union types.
enum Enum40494 { X_40494 };
union Union40494 { int x; };
void issue40494(enum Enum40494 e, union Union40494* up) {}

// Issue 45451, bad handling of go:notinheap types.
typedef struct issue45451Undefined issue45451;

// Issue 49633, example of cgo.Handle with void*.
extern void GoFunc49633(void*);
void cfunc49633(void *context) { GoFunc49633(context); }

*/
import _ "unsafe"

import (
	"context"
	"fmt"
	"math"
	"math/rand"
	"os"
	"os/signal"
	"reflect"
	"runtime"
	"runtime/cgo"
	"sync"
	"syscall"
	"testing"
	"time"
	"unsafe"
)

// alignment

func testAlign(t *testing.T) {
	var evt  /*line :951:10*/_Ctype_SDL_KeyboardEvent /*line :951:29*/
	( /*line :952:2*/_Cfunc_makeEvent /*line :952:12*/)(&evt)
	if ( /*line :953:5*/_Cfunc_same /*line :953:10*/)(&evt, evt.typ, evt.which, evt.state, evt.keysym.scancode, evt.keysym.sym, evt.keysym.mod, evt.keysym.unicode) == 0 {
		t.Error("*** bad alignment")
		( /*line :955:3*/_Cfunc_cTest /*line :955:9*/)(&evt)
		t.Errorf("Go: %#x %#x %#x %#x %#x %#x %#x\n",
			evt.typ, evt.which, evt.state, evt.keysym.scancode,
			evt.keysym.sym, evt.keysym.mod, evt.keysym.unicode)
		t.Error(evt)
	}
}

// api

const greeting = "hello, world"

type testPair struct {
	Name      string
	Got, Want interface{}
}

var testPairs = []testPair{
	{"GoString", ( /*line :973:15*/_Cfunc_GoString /*line :973:24*/)(( /*line :973:26*/*_Cvar_greeting /*line :973:35*/)), greeting},
	{"GoStringN", ( /*line :974:16*/_Cfunc_GoStringN /*line :974:26*/)(( /*line :974:28*/*_Cvar_greeting /*line :974:37*/), 5), greeting[:5]},
	{"GoBytes", func() []byte{ _cgo0 := /*line :975:24*/unsafe.Pointer(*_Cvar_greeting /*line :975:49*/); var _cgo1 _Ctype_int = /*line :975:52*/5; _cgoCheckPointer(_cgo0, nil); return /*line :975:54*/_Cfunc_GoBytes(_cgo0, _cgo1); }(), []byte(greeting[:5])},
}

func testHelpers(t *testing.T) {
	for _, pair := range testPairs {
		if !reflect.DeepEqual(pair.Got, pair.Want) {
			t.Errorf("%s: got %#v, want %#v", pair.Name, pair.Got, pair.Want)
		}
	}
}

// basic test cases

const EINVAL = ( /*line :988:16*/_Ciconst_EINVAL /*line :988:23*/) /* test #define */

var KILO = ( /*line :990:12*/_Ciconst_KILO /*line :990:17*/)

func uuidgen() {
	var uuid  /*line :993:11*/_Ctype_cgo_uuid_t /*line :993:23*/
	( /*line :994:2*/_Cfunc_uuid_generate /*line :994:16*/)(&uuid[0])
}

func Strtol(s string, base int) (int, error) {
	p := ( /*line :998:7*/_Cfunc_CString /*line :998:15*/)(s)
	n, err := ( /*line :999:12*/_C2func_strtol /*line :999:19*/)(p, nil,  /*line :999:29*/_Ctype_int /*line :999:34*/(base))
	func() { _cgo0 := /*line :1000:9*/unsafe.Pointer(p); _cgoCheckPointer(_cgo0, nil); /*line :1000:27*/_Cfunc_free(_cgo0); }()
	return int(n), err
}

func Atol(s string) int {
	p := ( /*line :1005:7*/_Cfunc_CString /*line :1005:15*/)(s)
	n := ( /*line :1006:7*/_Cfunc_atol /*line :1006:12*/)(p)
	func() { _cgo0 := /*line :1007:9*/unsafe.Pointer(p); _cgoCheckPointer(_cgo0, nil); /*line :1007:27*/_Cfunc_free(_cgo0); }()
	return int(n)
}

func testConst(t *testing.T) {
	( /*line :1012:2*/_Cfunc_myConstFunc /*line :1012:14*/)(nil, 0, nil)
}

func testEnum(t *testing.T) {
	if ( /*line :1016:5*/_Ciconst_Enum1 /*line :1016:11*/) != 1 || ( /*line :1016:21*/_Ciconst_Enum2 /*line :1016:27*/) != 2 {
		t.Error("bad enum", ( /*line :1017:23*/_Ciconst_Enum1 /*line :1017:29*/), ( /*line :1017:32*/_Ciconst_Enum2 /*line :1017:38*/))
	}
}

func testNamedEnum(t *testing.T) {
	e := new( /*line :1022:11*/_Ctype_enum_E /*line :1022:19*/)

	*e = ( /*line :1024:7*/_Ciconst_Enum1 /*line :1024:13*/)
	if *e != 1 {
		t.Error("bad enum", ( /*line :1026:23*/_Ciconst_Enum1 /*line :1026:29*/))
	}

	*e = ( /*line :1029:7*/_Ciconst_Enum2 /*line :1029:13*/)
	if *e != 2 {
		t.Error("bad enum", ( /*line :1031:23*/_Ciconst_Enum2 /*line :1031:29*/))
	}
}

func testCastToEnum(t *testing.T) {
	e :=  /*line :1036:7*/_Ctype_enum_E /*line :1036:15*/(( /*line :1036:16*/_Ciconst_Enum1 /*line :1036:22*/))
	if e != 1 {
		t.Error("bad enum", ( /*line :1038:23*/_Ciconst_Enum1 /*line :1038:29*/))
	}

	e =  /*line :1041:6*/_Ctype_enum_E /*line :1041:14*/(( /*line :1041:15*/_Ciconst_Enum2 /*line :1041:21*/))
	if e != 2 {
		t.Error("bad enum", ( /*line :1043:23*/_Ciconst_Enum2 /*line :1043:29*/))
	}
}

func testAtol(t *testing.T) {
	l := Atol("123")
	if l != 123 {
		t.Error("Atol 123: ", l)
	}
}

func testErrno(t *testing.T) {
	p := ( /*line :1055:7*/_Cfunc_CString /*line :1055:15*/)("no-such-file")
	m := ( /*line :1056:7*/_Cfunc_CString /*line :1056:15*/)("r")
	f, err := ( /*line :1057:12*/_C2func_fopen /*line :1057:18*/)(p, m)
	func() { _cgo0 := /*line :1058:9*/unsafe.Pointer(p); _cgoCheckPointer(_cgo0, nil); /*line :1058:27*/_Cfunc_free(_cgo0); }()
	func() { _cgo0 := /*line :1059:9*/unsafe.Pointer(m); _cgoCheckPointer(_cgo0, nil); /*line :1059:27*/_Cfunc_free(_cgo0); }()
	if err == nil {
		func() _Ctype_int{ _cgo0 := /*line :1061:12*/f; _cgoCheckPointer(_cgo0, nil); return /*line :1061:14*/_Cfunc_fclose(_cgo0); }()
		t.Fatalf("C.fopen: should fail")
	}
	if err != syscall.ENOENT {
		t.Fatalf("C.fopen: unexpected error: %v", err)
	}
}

func testMultipleAssign(t *testing.T) {
	p := ( /*line :1070:7*/_Cfunc_CString /*line :1070:15*/)("234")
	n, m := ( /*line :1071:10*/_Cfunc_strtol /*line :1071:17*/)(p, nil, 345), ( /*line :1071:33*/_Cfunc_strtol /*line :1071:40*/)(p, nil, 10)
	if runtime.GOOS == "openbsd" {
		// Bug in OpenBSD strtol(3) - base > 36 succeeds.
		if (n != 0 && n != 239089) || m != 234 {
			t.Fatal("Strtol x2: ", n, m)
		}
	} else if n != 0 || m != 234 {
		t.Fatal("Strtol x2: ", n, m)
	}
	func() { _cgo0 := /*line :1080:9*/unsafe.Pointer(p); _cgoCheckPointer(_cgo0, nil); /*line :1080:27*/_Cfunc_free(_cgo0); }()
}

var (
	cuint  = ( /*line :1084:12*/_Ctype_uint /*line :1084:18*/)(0)
	culong  /*line :1085:9*/_Ctype_ulong /*line :1085:16*/
	cchar   /*line :1086:9*/_Ctype_char /*line :1086:15*/
)

type Context struct {
	ctx * /*line :1090:7*/_Ctype_struct_ibv_context /*line :1090:27*/
}

func benchCgoCall(b *testing.B) {
	b.Run("add-int", func(b *testing.B) {
		const x =  /*line :1095:13*/_Ctype_int /*line :1095:18*/(2)
		const y =  /*line :1096:13*/_Ctype_int /*line :1096:18*/(3)

		for i := 0; i < b.N; i++ {
			( /*line :1099:4*/_Cfunc_add /*line :1099:8*/)(x, y)
		}
	})

	b.Run("one-pointer", func(b *testing.B) {
		var a0  /*line :1104:10*/_Ctype_VkDeviceCreateInfo /*line :1104:30*/
		for i := 0; i < b.N; i++ {
			func() { _cgoBase0 := /*line :1106:27*/&a0; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :1106:31*/_Cfunc_handleComplexPointer(_cgo0); }()
		}
	})
	b.Run("eight-pointers", func(b *testing.B) {
		var a0, a1, a2, a3, a4, a5, a6, a7  /*line :1110:38*/_Ctype_VkDeviceCreateInfo /*line :1110:58*/
		for i := 0; i < b.N; i++ {
			func() { _cgoBase0 := /*line :1112:28*/&a0; _cgo0 := _cgoBase0; _cgoBase1 := /*line :1112:33*/&a1; _cgo1 := _cgoBase1; _cgoBase2 := /*line :1112:38*/&a2; _cgo2 := _cgoBase2; _cgoBase3 := /*line :1112:43*/&a3; _cgo3 := _cgoBase3; _cgoBase4 := /*line :1112:48*/&a4; _cgo4 := _cgoBase4; _cgoBase5 := /*line :1112:53*/&a5; _cgo5 := _cgoBase5; _cgoBase6 := /*line :1112:58*/&a6; _cgo6 := _cgoBase6; _cgoBase7 := /*line :1112:63*/&a7; _cgo7 := _cgoBase7; _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); _cgoCheckPointer(_cgoBase4, 0 == 0); _cgoCheckPointer(_cgoBase5, 0 == 0); _cgoCheckPointer(_cgoBase6, 0 == 0); _cgoCheckPointer(_cgoBase7, 0 == 0); /*line :1112:67*/_Cfunc_handleComplexPointer8(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
		}
	})
	b.Run("eight-pointers-nil", func(b *testing.B) {
		var a0, a1, a2, a3, a4, a5, a6, a7 * /*line :1116:39*/_Ctype_VkDeviceCreateInfo /*line :1116:59*/
		for i := 0; i < b.N; i++ {
			func() { _cgo0 := /*line :1118:28*/a0; _cgo1 := /*line :1118:32*/a1; _cgo2 := /*line :1118:36*/a2; _cgo3 := /*line :1118:40*/a3; _cgo4 := /*line :1118:44*/a4; _cgo5 := /*line :1118:48*/a5; _cgo6 := /*line :1118:52*/a6; _cgo7 := /*line :1118:56*/a7; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); _cgoCheckPointer(_cgo4, nil); _cgoCheckPointer(_cgo5, nil); _cgoCheckPointer(_cgo6, nil); _cgoCheckPointer(_cgo7, nil); /*line :1118:59*/_Cfunc_handleComplexPointer8(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
		}
	})
	b.Run("eight-pointers-array", func(b *testing.B) {
		var a [8] /*line :1122:12*/_Ctype_VkDeviceCreateInfo /*line :1122:32*/
		for i := 0; i < b.N; i++ {
			func() { _cgoIndex0 := &/*line :1124:29*/a; _cgo0 := /*line :1124:28*/&(*_cgoIndex0)[0]; _cgoIndex1 := &/*line :1124:36*/a; _cgo1 := /*line :1124:35*/&(*_cgoIndex1)[1]; _cgoIndex2 := &/*line :1124:43*/a; _cgo2 := /*line :1124:42*/&(*_cgoIndex2)[2]; _cgoIndex3 := &/*line :1124:50*/a; _cgo3 := /*line :1124:49*/&(*_cgoIndex3)[3]; _cgoIndex4 := &/*line :1124:57*/a; _cgo4 := /*line :1124:56*/&(*_cgoIndex4)[4]; _cgoIndex5 := &/*line :1124:64*/a; _cgo5 := /*line :1124:63*/&(*_cgoIndex5)[5]; _cgoIndex6 := &/*line :1124:71*/a; _cgo6 := /*line :1124:70*/&(*_cgoIndex6)[6]; _cgoIndex7 := &/*line :1124:78*/a; _cgo7 := /*line :1124:77*/&(*_cgoIndex7)[7]; _cgoCheckPointer(_cgo0, *_cgoIndex0); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo2, *_cgoIndex2); _cgoCheckPointer(_cgo3, *_cgoIndex3); _cgoCheckPointer(_cgo4, *_cgoIndex4); _cgoCheckPointer(_cgo5, *_cgoIndex5); _cgoCheckPointer(_cgo6, *_cgoIndex6); _cgoCheckPointer(_cgo7, *_cgoIndex7); /*line :1124:83*/_Cfunc_handleComplexPointer8(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
		}
	})
	b.Run("eight-pointers-slice", func(b *testing.B) {
		a := make([] /*line :1128:15*/_Ctype_VkDeviceCreateInfo /*line :1128:35*/, 8)
		for i := 0; i < b.N; i++ {
			func() { _cgoIndex0 := &/*line :1130:29*/a; _cgo0 := /*line :1130:28*/&(*_cgoIndex0)[0]; _cgoIndex1 := &/*line :1130:36*/a; _cgo1 := /*line :1130:35*/&(*_cgoIndex1)[1]; _cgoIndex2 := &/*line :1130:43*/a; _cgo2 := /*line :1130:42*/&(*_cgoIndex2)[2]; _cgoIndex3 := &/*line :1130:50*/a; _cgo3 := /*line :1130:49*/&(*_cgoIndex3)[3]; _cgoIndex4 := &/*line :1130:57*/a; _cgo4 := /*line :1130:56*/&(*_cgoIndex4)[4]; _cgoIndex5 := &/*line :1130:64*/a; _cgo5 := /*line :1130:63*/&(*_cgoIndex5)[5]; _cgoIndex6 := &/*line :1130:71*/a; _cgo6 := /*line :1130:70*/&(*_cgoIndex6)[6]; _cgoIndex7 := &/*line :1130:78*/a; _cgo7 := /*line :1130:77*/&(*_cgoIndex7)[7]; _cgoCheckPointer(_cgo0, *_cgoIndex0); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo2, *_cgoIndex2); _cgoCheckPointer(_cgo3, *_cgoIndex3); _cgoCheckPointer(_cgo4, *_cgoIndex4); _cgoCheckPointer(_cgo5, *_cgoIndex5); _cgoCheckPointer(_cgo6, *_cgoIndex6); _cgoCheckPointer(_cgo7, *_cgoIndex7); /*line :1130:83*/_Cfunc_handleComplexPointer8(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
		}
	})
}

// Benchmark measuring overhead from Go to C and back to Go (via a callback)
func benchCallback(b *testing.B) {
	var x = false
	for i := 0; i < b.N; i++ {
		nestedCall(func() { x = true })
	}
	if !x {
		b.Fatal("nestedCall was not invoked")
	}
}

var sinkString string

func benchGoString(b *testing.B) {
	for i := 0; i < b.N; i++ {
		sinkString = ( /*line :1150:16*/_Cfunc_GoString /*line :1150:25*/)(( /*line :1150:27*/*_Cvar_cstr /*line :1150:32*/))
	}
	const want = "abcefghijklmnopqrstuvwxyzABCEFGHIJKLMNOPQRSTUVWXYZ1234567890"
	if sinkString != want {
		b.Fatalf("%q != %q", sinkString, want)
	}
}

// Static (build-time) test that syntax traversal visits all operands of s[i:j:k].
func sliceOperands(array [2000]int) {
	_ = array[( /*line :1160:12*/_Ciconst_KILO /*line :1160:17*/):( /*line :1160:19*/_Ciconst_KILO /*line :1160:24*/):( /*line :1160:26*/_Ciconst_KILO /*line :1160:31*/)] // no type error
}

// set in cgo_thread_lock.go init
var testThreadLockFunc = func(*testing.T) {}

// complex alignment

func TestComplexAlign(t *testing.T) {
	if ( /*line :1169:5*/*_Cvar_cplxAlign /*line :1169:15*/).x != 3.14 {
		t.Errorf("got %v, expected 3.14", ( /*line :1170:37*/*_Cvar_cplxAlign /*line :1170:47*/).x)
	}
	if ( /*line :1172:5*/*_Cvar_cplxAlign /*line :1172:15*/).y != 2.17 {
		t.Errorf("got %v, expected 2.17", ( /*line :1173:37*/*_Cvar_cplxAlign /*line :1173:47*/).y)
	}
}

// constants and pointer checking

func testCheckConst(t *testing.T) {
	// The test is that this compiles successfully.
	p := ( /*line :1181:7*/_Cfunc__CMalloc /*line :1181:14*/)( /*line :1181:16*/_Ctype_size_t /*line :1181:24*/(unsafe.Sizeof( /*line :1181:39*/_Ctype_int /*line :1181:44*/(0))))
	defer func() func() { _cgo0 := /*line :1182:15*/p; return func() { _cgoCheckPointer(_cgo0, nil); /*line :1182:17*/_Cfunc_free(_cgo0); }}()()
	func() { _cgoBase0 := /*line :1183:19*/&_Ctype_CheckConstStruct /*line :1183:38*/{(*_Ctype_int /*line :1183:46*/)(p)}; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = /*line :1183:53*/_Ciconst_CheckConstVal /*line :1183:68*/; _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :1183:69*/_Cfunc_CheckConstFunc(_cgo0, _cgo1); }()
}

// duplicate symbol

func duplicateSymbols() {
	fmt.Printf("%v %v %v\n", ( /*line :1189:27*/*_Cvar_base_symbol /*line :1189:39*/), ( /*line :1189:42*/_Cmacro_alias_one() /*line :1189:52*/), ( /*line :1189:55*/_Cmacro_alias_two() /*line :1189:65*/))
}

// environment

// This is really an os package test but here for convenience.
func testSetEnv(t *testing.T) {
	if runtime.GOOS == "windows" {
		// Go uses SetEnvironmentVariable on windows. However,
		// C runtime takes a *copy* at process startup of the
		// OS environment, and stores it in environ/envp.
		// It is this copy that	getenv/putenv manipulate.
		t.Logf("skipping test")
		return
	}
	const key = "CGO_OS_TEST_KEY"
	const val = "CGO_OS_TEST_VALUE"
	os.Setenv(key, val)
	keyc := ( /*line :1207:10*/_Cfunc_CString /*line :1207:18*/)(key)
	defer func() func() { _cgo0 := /*line :1208:15*/unsafe.Pointer(keyc); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1208:36*/_Cfunc_free(_cgo0); }}()()
	v := ( /*line :1209:7*/_Cfunc_getenv /*line :1209:14*/)(keyc)
	if uintptr(unsafe.Pointer(v)) == 0 {
		t.Fatal("getenv returned NULL")
	}
	vs := ( /*line :1213:8*/_Cfunc_GoString /*line :1213:17*/)(v)
	if vs != val {
		t.Fatalf("getenv() = %q; want %q", vs, val)
	}
}

// function pointer variables

func callBridge(f  /*line :1221:19*/_Ctype_intFunc /*line :1221:28*/) int {
	return int(( /*line :1222:13*/_Cfunc_bridge_int_func /*line :1222:29*/)(f))
}

func callCBridge(f  /*line :1225:20*/_Ctype_intFunc /*line :1225:29*/)  /*line :1225:31*/_Ctype_int /*line :1225:36*/ {
	return ( /*line :1226:9*/_Cfunc_bridge_int_func /*line :1226:25*/)(f)
}

func testFpVar(t *testing.T) {
	const expected = 42
	f :=  /*line :1231:7*/_Ctype_intFunc /*line :1231:16*/(( /*line :1231:17*/_Cgo_ptr(_Cfpvar_fp_fortytwo) /*line :1231:26*/))
	res1 := ( /*line :1232:10*/_Cfunc_bridge_int_func /*line :1232:26*/)(f)
	if r1 := int(res1); r1 != expected {
		t.Errorf("got %d, want %d", r1, expected)
	}
	res2 := callCBridge(f)
	if r2 := int(res2); r2 != expected {
		t.Errorf("got %d, want %d", r2, expected)
	}
	r3 := callBridge(f)
	if r3 != expected {
		t.Errorf("got %d, want %d", r3, expected)
	}
}

// issue 1222
type AsyncEvent struct {
	event  /*line :1248:8*/_Ctype_struct_ibv_async_event /*line :1248:32*/
}

// issue 1635

func test1635(t *testing.T) {
	( /*line :1254:2*/_Cfunc_scatter /*line :1254:10*/)()
	if v := ( /*line :1255:10*/*_Cvar_hola /*line :1255:15*/); v != 0 {
		t.Fatalf("C.hola is %d, should be 0", v)
	}
	if v := ( /*line :1258:10*/_Cfunc_testHola /*line :1258:19*/)(); v != 0 {
		t.Fatalf("C.testHola() is %d, should be 0", v)
	}
}

// issue 2470

func testUnsignedInt(t *testing.T) {
	a := (int64)(( /*line :1266:15*/_Ciconst_UINT32VAL /*line :1266:25*/))
	b := (int64)(0xc008427b)
	if a != b {
		t.Errorf("Incorrect unsigned int - got %x, want %x", a, b)
	}
}

// issue 3250

func test3250(t *testing.T) {
	if runtime.GOOS == "windows" {
		t.Skip("not applicable on windows")
	}

	t.Skip("skipped, see golang.org/issue/5885")
	var (
		thres = 1
		sig   = syscall_dot_SIGCHLD
	)
	type result struct {
		n   int
		sig os.Signal
	}
	var (
		sigCh     = make(chan os.Signal, 10)
		waitStart = make(chan struct{})
		waitDone  = make(chan result)
	)

	signal.Notify(sigCh, sig)

	go func() {
		n := 0
		alarm := time.After(time.Second * 3)
		for {
			select {
			case <-waitStart:
				waitStart = nil
			case v := <-sigCh:
				n++
				if v != sig || n > thres {
					waitDone <- result{n, v}
					return
				}
			case <-alarm:
				waitDone <- result{n, sig}
				return
			}
		}
	}()

	waitStart <- struct{}{}
	( /*line :1318:2*/_Cfunc_testSendSIG /*line :1318:14*/)()
	r := <-waitDone
	if r.sig != sig {
		t.Fatalf("received signal %v, but want %v", r.sig, sig)
	}
	t.Logf("got %d signals\n", r.n)
	if r.n <= thres {
		t.Fatalf("expected more than %d", thres)
	}
}

// issue 3261

func testLibgcc(t *testing.T) {
	var table = []struct {
		in, out  /*line :1333:11*/_Ctype_int /*line :1333:16*/
	}{
		{0, 0},
		{1, 1},
		{-42, 42},
		{1000300, 1000300},
		{1 - 1<<31, 1<<31 - 1},
	}
	for _, v := range table {
		if o := ( /*line :1342:11*/_Cfunc_vabs /*line :1342:16*/)(v.in); o != v.out {
			t.Fatalf("abs(%d) got %d, should be %d", v.in, o, v.out)
			return
		}
	}
}

// issue 3729

func test3729(t *testing.T) {
	if runtime.GOOS == "windows" {
		t.Skip("skipping on windows")
	}

	_, e := ( /*line :1356:10*/_C2func_g /*line :1356:12*/)()
	if e != syscall.E2BIG {
		t.Errorf("got %q, expect %q", e, syscall.E2BIG)
	}
	_, e = ( /*line :1360:9*/_C2func_g2 /*line :1360:12*/)(( /*line :1360:14*/_Ciconst_EINVAL /*line :1360:21*/), ( /*line :1360:24*/*_Cvar__expA /*line :1360:30*/), ( /*line :1360:33*/*_Cvar__expB /*line :1360:39*/), ( /*line :1360:42*/*_Cvar__expC /*line :1360:48*/), ( /*line :1360:51*/*_Cvar__expD /*line :1360:57*/))
	if e != syscall.EINVAL {
		t.Errorf("got %q, expect %q", e, syscall.EINVAL)
	}
}

// issue 3945

func testPrintf(t *testing.T) {
	( /*line :1369:2*/_Cfunc_say /*line :1369:6*/)()
}

// issue 4054

var issue4054a = []int{( /*line :1374:24*/_Ciconst_A /*line :1374:26*/), ( /*line :1374:29*/_Ciconst_B /*line :1374:31*/), ( /*line :1374:34*/_Ciconst_C /*line :1374:36*/), ( /*line :1374:39*/_Ciconst_D /*line :1374:41*/), ( /*line :1374:44*/_Ciconst_E /*line :1374:46*/), ( /*line :1374:49*/_Ciconst_F /*line :1374:51*/), ( /*line :1374:54*/_Ciconst_G /*line :1374:56*/), ( /*line :1374:59*/_Ciconst_H /*line :1374:61*/), ( /*line :1374:64*/_Cfconst_I /*line :1374:66*/), ( /*line :1374:69*/_Ciconst_J /*line :1374:71*/)}

// issue 4339

func test4339(t *testing.T) {
	func() { _cgoBase0 := /*line :1379:15*/&*_Cvar_exported4339 /*line :1379:30*/; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :1379:31*/_Cfunc_handle4339(_cgo0); }()
}

// issue 4417

func testBoolAlign(t *testing.T) {
	b := ( /*line :1385:7*/_Cfunc_c_bool /*line :1385:14*/)(true, true, 10, true, false)
	if b != 10 {
		t.Fatalf("found %d expected 10\n", b)
	}
	b = ( /*line :1389:6*/_Cfunc_c_bool /*line :1389:13*/)(true, true, 5, true, true)
	if b != 5 {
		t.Fatalf("found %d expected 5\n", b)
	}
	b = ( /*line :1393:6*/_Cfunc_c_bool /*line :1393:13*/)(true, true, 3, true, false)
	if b != 3 {
		t.Fatalf("found %d expected 3\n", b)
	}
	b = ( /*line :1397:6*/_Cfunc_c_bool /*line :1397:13*/)(false, false, 1, true, false)
	if b != 1 {
		t.Fatalf("found %d expected 1\n", b)
	}
	b = ( /*line :1401:6*/_Cfunc_c_bool /*line :1401:13*/)(false, true, 200, true, false)
	if b != 200 {
		t.Fatalf("found %d expected 200\n", b)
	}
}

// issue 4857

func test4857() {
	_ = ( /*line :1410:6*/_Cfunc_issue4857 /*line :1410:16*/)()
}

// issue 5224

func testCflags(t *testing.T) {
	is_windows := ( /*line :1416:16*/*_Cvar_is_windows /*line :1416:27*/) == 1
	if is_windows != (runtime.GOOS == "windows") {
		t.Errorf("is_windows: %v, runtime.GOOS: %s", is_windows, runtime.GOOS)
	}
	if ( /*line :1420:5*/*_Cvar_common /*line :1420:12*/) != 123 {
		t.Errorf("common: %v (expected 123)", ( /*line :1421:41*/*_Cvar_common /*line :1421:48*/))
	}
}

// issue 5227

func test5227(t *testing.T) {
	( /*line :1428:2*/_Cfunc_init /*line :1428:7*/)()
}

func selectfont()  /*line :1431:19*/_Ctype_Fontinfo /*line :1431:29*/ {
	return ( /*line :1432:9*/*_Cvar_SansTypeface /*line :1432:22*/)
}

// issue 5242

func test5242(t *testing.T) {
	if got := ( /*line :1438:12*/_Cfunc_issue5242 /*line :1438:22*/)( /*line :1438:24*/_Ctype_foo /*line :1438:29*/{},  /*line :1438:33*/_Ctype_bar /*line :1438:38*/{}); got != 5242 {
		t.Errorf("got %v", got)
	}
}

func test5603(t *testing.T) {
	var x [5]int64
	exp := int64(( /*line :1445:15*/*_Cvar_issue5603exp /*line :1445:28*/))
	x[0] = int64(( /*line :1446:15*/_Cfunc_issue5603foo0 /*line :1446:29*/)())
	x[1] = int64(( /*line :1447:15*/_Cfunc_issue5603foo1 /*line :1447:29*/)(nil))
	x[2] = int64(( /*line :1448:15*/_Cfunc_issue5603foo2 /*line :1448:29*/)(nil, nil))
	x[3] = int64(( /*line :1449:15*/_Cfunc_issue5603foo3 /*line :1449:29*/)(nil, nil, nil))
	x[4] = int64(( /*line :1450:15*/_Cfunc_issue5603foo4 /*line :1450:29*/)(nil, nil, nil, nil))
	for i, v := range x {
		if v != exp {
			t.Errorf("issue5603foo%d() returns %v, expected %v", i, v, exp)
		}
	}
}

// issue 5337

func test5337(t *testing.T) {
	( /*line :1461:2*/_Cfunc_test5337 /*line :1461:11*/)()
}

// issue 5740

func test5740(t *testing.T) {
	if v := ( /*line :1467:10*/_Cfunc_test5740a /*line :1467:20*/)() + ( /*line :1467:26*/_Cfunc_test5740b /*line :1467:36*/)(); v != 5 {
		t.Errorf("expected 5, got %v", v)
	}
}

// issue 5986

func test5986(t *testing.T) {
	( /*line :1475:2*/_Cfunc_output5986 /*line :1475:13*/)()
}

// issue 6128

func test6128() {
	// nothing to run, just make sure this compiles.
	_ = ( /*line :1482:6*/_Ciconst_X /*line :1482:8*/)
}

// issue 6390

func test6390(t *testing.T) {
	p1 := ( /*line :1488:8*/_Cfunc__CMalloc /*line :1488:15*/)(1024)
	if p1 == nil {
		t.Fatalf("C.malloc(1024) returned nil")
	}
	p2 := ( /*line :1492:8*/_Cfunc__CMalloc /*line :1492:15*/)(0)
	if p2 == nil {
		t.Fatalf("C.malloc(0) returned nil")
	}
	func() { _cgo0 := /*line :1496:9*/p1; _cgoCheckPointer(_cgo0, nil); /*line :1496:12*/_Cfunc_free(_cgo0); }()
	func() { _cgo0 := /*line :1497:9*/p2; _cgoCheckPointer(_cgo0, nil); /*line :1497:12*/_Cfunc_free(_cgo0); }()
}

func test6472() {
	// nothing to run, just make sure this compiles
	s := new( /*line :1502:11*/_Ctype_z /*line :1502:14*/)
	println(s.y[0].x)
}

// issue 6506

func test6506() {
	// nothing to run, just make sure this compiles
	var x  /*line :1510:8*/_Ctype_size_t /*line :1510:16*/

	( /*line :1512:2*/_Cfunc_calloc /*line :1512:9*/)(x, x)
	( /*line :1513:2*/_Cfunc__CMalloc /*line :1513:9*/)(x)
	( /*line :1514:2*/_Cfunc_realloc /*line :1514:10*/)(nil, x)
	( /*line :1515:2*/_Cfunc_memcpy /*line :1515:9*/)(nil, nil, x)
	( /*line :1516:2*/_Cfunc_memcmp /*line :1516:9*/)(nil, nil, x)
	( /*line :1517:2*/_Cfunc_memmove /*line :1517:10*/)(nil, nil, x)
	( /*line :1518:2*/_Cfunc_strncpy /*line :1518:10*/)(nil, nil, x)
	( /*line :1519:2*/_Cfunc_strncmp /*line :1519:10*/)(nil, nil, x)
	( /*line :1520:2*/_Cfunc_strncat /*line :1520:10*/)(nil, nil, x)
	x = ( /*line :1521:6*/_Cfunc_strxfrm /*line :1521:14*/)(nil, nil, x)
	( /*line :1522:2*/_Cfunc_memchr /*line :1522:9*/)(nil, 0, x)
	x = ( /*line :1523:6*/_Cfunc_strcspn /*line :1523:14*/)(nil, nil)
	x = ( /*line :1524:6*/_Cfunc_strspn /*line :1524:13*/)(nil, nil)
	( /*line :1525:2*/_Cfunc_memset /*line :1525:9*/)(nil, 0, x)
	x = ( /*line :1526:6*/_Cfunc_strlen /*line :1526:13*/)(nil)
	_ = x
}

// issue 6612

func testNaming(t *testing.T) {
	( /*line :1533:2*/_Cfunc_myfunc /*line :1533:9*/)()
	( /*line :1534:2*/_Cfunc_myfunc_def /*line :1534:13*/)()
	if v := ( /*line :1535:10*/*_Cvar_myvar /*line :1535:16*/); v != 5 {
		t.Errorf("C.myvar = %d, want 5", v)
	}
	if v := ( /*line :1538:10*/_Cmacro_myvar_def() /*line :1538:20*/); v != 5 {
		t.Errorf("C.myvar_def = %d, want 5", v)
	}
	if s := ( /*line :1541:10*/_Cfunc_GoString /*line :1541:19*/)(( /*line :1541:21*/*_Cvar_mytext /*line :1541:28*/)); s != "abcdef" {
		t.Errorf("C.mytext = %q, want %q", s, "abcdef")
	}
	if s := ( /*line :1544:10*/_Cfunc_GoString /*line :1544:19*/)(( /*line :1544:21*/_Cmacro_mytext_def() /*line :1544:32*/)); s != "abcdef" {
		t.Errorf("C.mytext_def = %q, want %q", s, "abcdef")
	}
	if c := ( /*line :1547:10*/_Ciconst_myenum /*line :1547:17*/); c != 1234 {
		t.Errorf("C.myenum = %v, want 1234", c)
	}
	if c := ( /*line :1550:10*/_Ciconst_myenum_def /*line :1550:21*/); c != 1234 {
		t.Errorf("C.myenum_def = %v, want 1234", c)
	}
	{
		const c = ( /*line :1554:13*/_Ciconst_myenum /*line :1554:20*/)
		if c != 1234 {
			t.Errorf("C.myenum as const = %v, want 1234", c)
		}
	}
	{
		const c = ( /*line :1560:13*/_Ciconst_myenum_def /*line :1560:24*/)
		if c != 1234 {
			t.Errorf("C.myenum as const = %v, want 1234", c)
		}
	}
	if c := ( /*line :1565:10*/_Ciconst_myint_def /*line :1565:20*/); c != 12345 {
		t.Errorf("C.myint_def = %v, want 12345", c)
	}
	{
		const c = ( /*line :1569:13*/_Ciconst_myint_def /*line :1569:23*/)
		if c != 12345 {
			t.Errorf("C.myint as const = %v, want 12345", c)
		}
	}

	if c := ( /*line :1575:10*/_Cfconst_myfloat_def /*line :1575:22*/); c != 1.5 {
		t.Errorf("C.myint_def = %v, want 1.5", c)
	}
	{
		const c = ( /*line :1579:13*/_Cfconst_myfloat_def /*line :1579:25*/)
		if c != 1.5 {
			t.Errorf("C.myint as const = %v, want 1.5", c)
		}
	}

	if s := ( /*line :1585:10*/_Csconst_mystring_def /*line :1585:23*/); s != "hello" {
		t.Errorf("C.mystring_def = %q, want %q", s, "hello")
	}
}

// issue 6907

func test6907(t *testing.T) {
	want := "yarn"
	if got := ( /*line :1594:12*/_Cfunc_GoString /*line :1594:21*/)(( /*line :1594:23*/_Cfunc_Issue6907CopyString /*line :1594:43*/)(want)); got != want {
		t.Errorf("C.GoString(C.Issue6907CopyString(%q)) == %q, want %q", want, got, want)
	}
}

// issue 7560

func test7560(t *testing.T) {
	// some mingw don't implement __packed__ correctly.
	if ( /*line :1603:5*/_Cfunc_offset7560 /*line :1603:16*/)() != 1 {
		t.Skip("C compiler did not pack struct")
	}

	// C.misaligned should have x but then a padding field to get to the end of the struct.
	// There should not be a field named 'y'.
	var v  /*line :1609:8*/_Ctype_misaligned /*line :1609:20*/
	rt := reflect.TypeOf(&v).Elem()
	if rt.NumField() != 2 || rt.Field(0).Name != "x" || rt.Field(1).Name != "_" {
		t.Errorf("unexpected fields in C.misaligned:\n")
		for i := 0; i < rt.NumField(); i++ {
			t.Logf("%+v\n", rt.Field(i))
		}
	}
}

// issue 7786

func f() {
	var x1 * /*line :1622:10*/_Ctype_typedef_test7786 /*line :1622:28*/
	var x2 * /*line :1623:10*/_Ctype_struct_test7786 /*line :1623:27*/
	x1 = x2
	x2 = x1
	func() { _cgo0 := /*line :1626:10*/x1; _cgoCheckPointer(_cgo0, nil); /*line :1626:13*/_Cfunc_f7786(_cgo0); }()
	func() { _cgo0 := /*line :1627:10*/x2; _cgoCheckPointer(_cgo0, nil); /*line :1627:13*/_Cfunc_f7786(_cgo0); }()
	func() { _cgo0 := /*line :1628:10*/x1; _cgoCheckPointer(_cgo0, nil); /*line :1628:13*/_Cfunc_g7786(_cgo0); }()
	func() { _cgo0 := /*line :1629:10*/x2; _cgoCheckPointer(_cgo0, nil); /*line :1629:13*/_Cfunc_g7786(_cgo0); }()

	var b1 * /*line :1631:10*/_Ctype_typedef_body7786 /*line :1631:28*/
	var b2 * /*line :1632:10*/_Ctype_struct_body7786 /*line :1632:27*/
	b1 = b2
	b2 = b1
	( /*line :1635:2*/_Cfunc_b7786 /*line :1635:8*/)(b1)
	( /*line :1636:2*/_Cfunc_b7786 /*line :1636:8*/)(b2)
	( /*line :1637:2*/_Cfunc_c7786 /*line :1637:8*/)(b1)
	( /*line :1638:2*/_Cfunc_c7786 /*line :1638:8*/)(b2)

	var u1 * /*line :1640:10*/_Ctype_typedef_union7786 /*line :1640:29*/
	var u2 * /*line :1641:10*/_Ctype_union_union7786 /*line :1641:27*/
	u1 = u2
	u2 = u1
	func() { _cgo0 := /*line :1644:10*/u1; _cgoCheckPointer(_cgo0, nil); /*line :1644:13*/_Cfunc_u7786(_cgo0); }()
	func() { _cgo0 := /*line :1645:10*/u2; _cgoCheckPointer(_cgo0, nil); /*line :1645:13*/_Cfunc_u7786(_cgo0); }()
	func() { _cgo0 := /*line :1646:10*/u1; _cgoCheckPointer(_cgo0, nil); /*line :1646:13*/_Cfunc_v7786(_cgo0); }()
	func() { _cgo0 := /*line :1647:10*/u2; _cgoCheckPointer(_cgo0, nil); /*line :1647:13*/_Cfunc_v7786(_cgo0); }()
}

// issue 8092

func test8092(t *testing.T) {
	tests := []struct {
		s    string
		a, b * /*line :1655:9*/_Ctype_char /*line :1655:15*/
	}{
		{"text", &( /*line :1657:13*/*_Cvar_text /*line :1657:18*/)[0], ( /*line :1657:24*/_Cfunc_ctext /*line :1657:30*/)()},
		{"data", &( /*line :1658:13*/*_Cvar_data /*line :1658:18*/)[0], ( /*line :1658:24*/_Cfunc_cdata /*line :1658:30*/)()},
	}
	for _, test := range tests {
		if test.a != test.b {
			t.Errorf("%s: pointer mismatch: %v != %v", test.s, test.a, test.b)
		}
		if got := ( /*line :1664:13*/_Cfunc_GoString /*line :1664:22*/)(test.a); got != test.s {
			t.Errorf("%s: points at %#v, want %#v", test.s, got, test.s)
		}
	}
}

// issues 8368 and 8441

func issue8368(one * /*line :1672:21*/_Ctype_struct_one /*line :1672:33*/, two * /*line :1672:40*/_Ctype_struct_two /*line :1672:52*/) {
}

func issue8441(one * /*line :1675:21*/_Ctype_one /*line :1675:26*/, two * /*line :1675:33*/_Ctype_two /*line :1675:38*/) {
	issue8441(two.x, one.x)
}

// issue 8428

var _ =  /*line :1681:9*/_Ctype_struct_issue8428one /*line :1681:30*/{
	b:  /*line :1682:5*/_Ctype_char /*line :1682:11*/(0),
	// The trailing rest field is not available in cgo.
	// See issue 11925.
	// rest: [0]C.char{},
}

var _ =  /*line :1688:9*/_Ctype_struct_issue8428two /*line :1688:30*/{
	p:    unsafe.Pointer(nil),
	b:     /*line :1690:8*/_Ctype_char /*line :1690:14*/(0),
	rest: [0] /*line :1691:11*/_Ctype_char /*line :1691:17*/{},
}

var _ =  /*line :1694:9*/_Ctype_struct_issue8428three /*line :1694:32*/{
	w: [1][2][3][0] /*line :1695:17*/_Ctype_char /*line :1695:23*/{},
	x: [2][3][0][1] /*line :1696:17*/_Ctype_char /*line :1696:23*/{},
	y: [3][0][1][2] /*line :1697:17*/_Ctype_char /*line :1697:23*/{},
	z: [0][1][2][3] /*line :1698:17*/_Ctype_char /*line :1698:23*/{},
}

// issue 8811

func test8811(t *testing.T) {
	( /*line :1704:2*/_Cfunc_issue8811Execute /*line :1704:19*/)()
}

// issue 9557

func test9557(t *testing.T) {
	// implicitly dereference a Go variable
	foo := ( /*line :1711:9*/*_Cvar_issue9557foo /*line :1711:22*/)
	if v := foo.a; v != 42 {
		t.Fatalf("foo.a expected 42, but got %d", v)
	}

	// explicitly dereference a C variable
	if v := (*( /*line :1717:12*/*_Cvar_issue9557foo /*line :1717:25*/)).a; v != 42 {
		t.Fatalf("(*C.issue9557foo).a expected 42, but is %d", v)
	}

	// implicitly dereference a C variable
	if v := ( /*line :1722:10*/*_Cvar_issue9557foo /*line :1722:23*/).a; v != 42 {
		t.Fatalf("C.issue9557foo.a expected 42, but is %d", v)
	}
}

// issue 8331 part 1

func issue8331a()  /*line :1729:19*/_Ctype_issue8331 /*line :1729:30*/ {
	return issue8331Var
}

// issue 10303

func test10303(t *testing.T, n int) {
	if runtime.Compiler == "gccgo" {
		t.Skip("gccgo permits C pointers on the stack")
	}

	// Run at a few different stack depths just to avoid an unlucky pass
	// due to variables ending up on different pages.
	if n > 0 {
		test10303(t, n-1)
	}
	if t.Failed() {
		return
	}
	var x, y, z, v, si  /*line :1748:21*/_Ctype_int /*line :1748:26*/
	var s  /*line :1749:8*/_Ctype_Struct /*line :1749:16*/
	( /*line :1750:2*/_Cfunc_setintstar /*line :1750:13*/)(&x)
	( /*line :1751:2*/_Cfunc_setintptr /*line :1751:12*/)(&y)
	func() { _cgoBase0 := /*line :1752:30*/&v; _cgo0 := /*line :1752:15*/unsafe.Pointer(_cgoBase0); _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :1752:34*/_Cfunc_setvoidptr(_cgo0); }()
	s.P = &si
	( /*line :1754:2*/_Cfunc_setstruct /*line :1754:12*/)(s)

	if uintptr(unsafe.Pointer(&x))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {
		t.Error("C int* argument on stack")
	}
	if uintptr(unsafe.Pointer(&y))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {
		t.Error("C intptr argument on stack")
	}
	if uintptr(unsafe.Pointer(&v))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {
		t.Error("C void* argument on stack")
	}
	if uintptr(unsafe.Pointer(&si))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {
		t.Error("C struct field pointer on stack")
	}
}

// issue 11925

func test11925(t *testing.T) {
	if ( /*line :1773:5*/_Ciconst_sizeof_struct_a11925 /*line :1773:26*/) != unsafe.Sizeof( /*line :1773:45*/_Ctype_struct_a11925 /*line :1773:60*/{}) {
		t.Errorf("size of a changed: C %d, Go %d", ( /*line :1774:46*/_Ciconst_sizeof_struct_a11925 /*line :1774:67*/), unsafe.Sizeof( /*line :1774:84*/_Ctype_struct_a11925 /*line :1774:99*/{}))
	}
	if ( /*line :1776:5*/_Ciconst_sizeof_struct_b11925 /*line :1776:26*/) != unsafe.Sizeof( /*line :1776:45*/_Ctype_struct_b11925 /*line :1776:60*/{}) {
		t.Errorf("size of b changed: C %d, Go %d", ( /*line :1777:46*/_Ciconst_sizeof_struct_b11925 /*line :1777:67*/), unsafe.Sizeof( /*line :1777:84*/_Ctype_struct_b11925 /*line :1777:99*/{}))
	}
}

// issue 12030

func test12030(t *testing.T) {
	buf := (* /*line :1784:11*/_Ctype_char /*line :1784:17*/)(( /*line :1784:19*/_Cfunc__CMalloc /*line :1784:26*/)(256))
	defer func() func() { _cgo0 := /*line :1785:15*/unsafe.Pointer(buf); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1785:35*/_Cfunc_free(_cgo0); }}()()
	for _, f := range []float64{1.0, 2.0, 3.14} {
		( /*line :1787:3*/_Cfunc_issue12030conv /*line :1787:18*/)(buf,  /*line :1787:25*/_Ctype_double /*line :1787:33*/(f))
		got := ( /*line :1788:10*/_Cfunc_GoString /*line :1788:19*/)(buf)
		if want := fmt.Sprintf("d=%g", f); got != want {
			t.Fatalf("C.sprintf failed for %g: %q != %q", f, got, want)
		}
	}
}

// issue 13402

var _  /*line :1797:7*/_Ctype_complexfloat /*line :1797:21*/
var _  /*line :1798:7*/_Ctype_complexdouble /*line :1798:22*/

// issue 13930
// Test that cgo's multiple-value special form for
// C function calls works in variable declaration statements.

var _, _ = ( /*line :1804:12*/_C2func_abs /*line :1804:16*/)(0)

// issue 14838

func test14838(t *testing.T) {
	data := []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	cData := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :1810:20*/data; _cgoCheckPointer(_cgo0, nil); return /*line :1810:25*/_Cfunc_CBytes(_cgo0); }()
	defer func() func() { _cgo0 := /*line :1811:15*/cData; return func() { _cgoCheckPointer(_cgo0, nil); /*line :1811:21*/_Cfunc_free(_cgo0); }}()()

	if ( /*line :1813:5*/_Cfunc_check_cbytes /*line :1813:18*/)((* /*line :1813:22*/_Ctype_char /*line :1813:28*/)(cData),  /*line :1813:38*/_Ctype_size_t /*line :1813:46*/(len(data))) == 0 {
		t.Fatalf("mismatched data: expected %v, got %v", data, (*(*[10]byte)(unsafe.Pointer(cData)))[:])
	}
}

// issue 17065

var sink  /*line :1820:10*/_Ctype_int /*line :1820:15*/

func test17065(t *testing.T) {
	if runtime.GOOS == "darwin" || runtime.GOOS == "ios" {
		t.Skip("broken on darwin; issue 17065")
	}
	for i := range ( /*line :1826:17*/*_Cvar_ii /*line :1826:20*/) {
		sink = ( /*line :1827:10*/*_Cvar_ii /*line :1827:13*/)[i]
	}
}

// issue 17537

func test17537(t *testing.T) {
	v :=  /*line :1834:7*/_Ctype_S17537 /*line :1834:15*/{i: 17537}
	if got, want := ( /*line :1835:18*/_Cfunc_I17537 /*line :1835:25*/)(&v),  /*line :1835:32*/_Ctype_int /*line :1835:37*/(17537); got != want {
		t.Errorf("got %d, want %d", got, want)
	}

	p := (* /*line :1839:9*/_Ctype_char /*line :1839:15*/)(( /*line :1839:17*/_Cfunc__CMalloc /*line :1839:24*/)(1))
	*p = 17
	if got, want := func() _Ctype_int{ _cgoBase0 := /*line :1841:27*/&p; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :1841:30*/_Cfunc_F17537(_cgo0); }(),  /*line :1841:32*/_Ctype_int /*line :1841:37*/(17); got != want {
		t.Errorf("got %d, want %d", got, want)
	}

	( /*line :1845:2*/_Cfunc_F18298 /*line :1845:9*/)(nil)
	var v18298  /*line :1846:13*/_Ctype_T18298_2 /*line :1846:23*/
	func() { _cgo0 := _Ctype_T18298_1 /*line :1847:21*/(v18298); _cgoCheckPointer(_cgo0, nil); /*line :1847:30*/_Cfunc_G18298(_cgo0); }()
}

// issue 17723

func testAPI() {
	var cs * /*line :1853:10*/_Ctype_char /*line :1853:16*/
	cs = ( /*line :1854:7*/_Cfunc_CString /*line :1854:15*/)("hello")
	defer func() func() { _cgo0 := /*line :1855:15*/unsafe.Pointer(cs); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1855:34*/_Cfunc_free(_cgo0); }}()()
	var s string
	s = ( /*line :1857:6*/_Cfunc_GoString /*line :1857:15*/)((* /*line :1857:19*/_Ctype_char /*line :1857:25*/)(( /*line :1857:27*/*_Cvar_api_hello /*line :1857:37*/)))
	s = ( /*line :1858:6*/_Cfunc_GoStringN /*line :1858:16*/)((* /*line :1858:20*/_Ctype_char /*line :1858:26*/)(( /*line :1858:28*/*_Cvar_api_hello /*line :1858:38*/)),  /*line :1858:42*/_Ctype_int /*line :1858:47*/(6))
	var b []byte
	b = func() []byte{ _cgo0 := /*line :1860:16*/unsafe.Pointer(*_Cvar_api_hello /*line :1860:42*/); var _cgo1 _Ctype_int = _Ctype_int /*line :1860:50*/(6); _cgoCheckPointer(_cgo0, nil); return /*line :1860:54*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	_, _ = s, b
	( /*line :1862:2*/_Cfunc_cstring_pointer_fun /*line :1862:22*/)(nil)
}

// issue 18126

func test18126(t *testing.T) {
	p := ( /*line :1868:7*/_Cfunc__CMalloc /*line :1868:14*/)(1)
	_, err := func() (_Ctype_void, error){ _cgoBase0 := /*line :1869:26*/&p; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :1869:29*/_C2func_Issue18126C(_cgo0); }()
	func() { _cgo0 := /*line :1870:9*/p; _cgoCheckPointer(_cgo0, nil); /*line :1870:11*/_Cfunc_free(_cgo0); }()
	_ = err
}

// issue 18720

func test18720(t *testing.T) {
	if got, want := ( /*line :1877:18*/_Csconst_HELLO_WORLD /*line :1877:30*/), "hello\000world"; got != want {
		t.Errorf("C.HELLO_WORLD == %q, expected %q", got, want)
	}

	if got, want := ( /*line :1881:18*/_Cmacro_VAR1() /*line :1881:23*/),  /*line :1881:26*/_Ctype_int /*line :1881:31*/(5); got != want {
		t.Errorf("C.VAR1 == %v, expected %v", got, want)
	}

	if got, want := *( /*line :1885:19*/_Cmacro_ADDR() /*line :1885:24*/),  /*line :1885:27*/_Ctype_int /*line :1885:32*/(5); got != want {
		t.Errorf("*C.ADDR == %v, expected %v", got, want)
	}

	if got, want := ( /*line :1889:18*/_Cmacro_CALL() /*line :1889:23*/),  /*line :1889:26*/_Ctype_int /*line :1889:31*/(6); got != want {
		t.Errorf("C.CALL == %v, expected %v", got, want)
	}

	if got, want := ( /*line :1893:18*/_Cmacro_CALL() /*line :1893:23*/),  /*line :1893:26*/_Ctype_int /*line :1893:31*/(7); got != want {
		t.Errorf("C.CALL == %v, expected %v", got, want)
	}

	// Issue 20125.
	if got, want := ( /*line :1898:18*/_Ciconst_SIZE_OF_FOO /*line :1898:30*/), 1; got != want {
		t.Errorf("C.SIZE_OF_FOO == %v, expected %v", got, want)
	}
}

// issue 20129

func test20129(t *testing.T) {
	if ( /*line :1906:5*/*_Cvar_issue20129 /*line :1906:16*/) != 0 {
		t.Fatal("test is broken")
	}
	( /*line :1909:2*/_Cfunc_issue20129Foo /*line :1909:16*/)()
	if ( /*line :1910:5*/*_Cvar_issue20129 /*line :1910:16*/) != 1 {
		t.Errorf("got %v but expected %v", ( /*line :1911:38*/*_Cvar_issue20129 /*line :1911:49*/), 1)
	}
	( /*line :1913:2*/_Cfunc_issue20129Bar /*line :1913:16*/)()
	if ( /*line :1914:5*/*_Cvar_issue20129 /*line :1914:16*/) != 2 {
		t.Errorf("got %v but expected %v", ( /*line :1915:38*/*_Cvar_issue20129 /*line :1915:49*/), 2)
	}
}

// issue 20369

func test20369(t *testing.T) {
	if ( /*line :1922:5*/_Ciconst_XUINT64_MAX /*line :1922:17*/) != math.MaxUint64 {
		t.Fatalf("got %v, want %v", uint64(( /*line :1923:38*/_Ciconst_XUINT64_MAX /*line :1923:50*/)), uint64(math.MaxUint64))
	}
}

// issue 21668

var issue21668_X = ( /*line :1929:20*/*_Cvar_x21668 /*line :1929:27*/)

// issue 21708

func test21708(t *testing.T) {
	if got, want := ( /*line :1934:18*/_Ciconst_CAST_TO_INT64 /*line :1934:32*/), -1; got != want {
		t.Errorf("C.CAST_TO_INT64 == %v, expected %v", got, want)
	}
}

// issue 21809

func test21809(t *testing.T) {
	longVar :=  /*line :1942:13*/_Ctype_long /*line :1942:19*/(3)
	typedefVar :=  /*line :1943:16*/_Ctype_MySigned_t /*line :1943:28*/(4)
	typedefTypedefVar :=  /*line :1944:23*/_Ctype_MySigned2_t /*line :1944:36*/(5)

	// all three should be considered identical to `long`
	if ret := ( /*line :1947:12*/_Cfunc_takes_long /*line :1947:23*/)(longVar); ret != 9 {
		t.Errorf("got %v but expected %v", ret, 9)
	}
	if ret := ( /*line :1950:12*/_Cfunc_takes_long /*line :1950:23*/)(typedefVar); ret != 16 {
		t.Errorf("got %v but expected %v", ret, 16)
	}
	if ret := ( /*line :1953:12*/_Cfunc_takes_long /*line :1953:23*/)(typedefTypedefVar); ret != 25 {
		t.Errorf("got %v but expected %v", ret, 25)
	}

	// They should also be identical to the typedef'd type
	if ret := ( /*line :1958:12*/_Cfunc_takes_typedef /*line :1958:26*/)(longVar); ret != 9 {
		t.Errorf("got %v but expected %v", ret, 9)
	}
	if ret := ( /*line :1961:12*/_Cfunc_takes_typedef /*line :1961:26*/)(typedefVar); ret != 16 {
		t.Errorf("got %v but expected %v", ret, 16)
	}
	if ret := ( /*line :1964:12*/_Cfunc_takes_typedef /*line :1964:26*/)(typedefTypedefVar); ret != 25 {
		t.Errorf("got %v but expected %v", ret, 25)
	}
}

// issue 22906

func test22906(t *testing.T) {
	var x1  /*line :1972:9*/_Ctype_jobject /*line :1972:18*/ = 0 // Note: 0, not nil. That makes sure we use uintptr for these types.
	_ = x1
	var x2  /*line :1974:9*/_Ctype_jclass /*line :1974:17*/ = 0
	_ = x2
	var x3  /*line :1976:9*/_Ctype_jthrowable /*line :1976:21*/ = 0
	_ = x3
	var x4  /*line :1978:9*/_Ctype_jstring /*line :1978:18*/ = 0
	_ = x4
	var x5  /*line :1980:9*/_Ctype_jarray /*line :1980:17*/ = 0
	_ = x5
	var x6  /*line :1982:9*/_Ctype_jbooleanArray /*line :1982:24*/ = 0
	_ = x6
	var x7  /*line :1984:9*/_Ctype_jbyteArray /*line :1984:21*/ = 0
	_ = x7
	var x8  /*line :1986:9*/_Ctype_jcharArray /*line :1986:21*/ = 0
	_ = x8
	var x9  /*line :1988:9*/_Ctype_jshortArray /*line :1988:22*/ = 0
	_ = x9
	var x10  /*line :1990:10*/_Ctype_jintArray /*line :1990:21*/ = 0
	_ = x10
	var x11  /*line :1992:10*/_Ctype_jlongArray /*line :1992:22*/ = 0
	_ = x11
	var x12  /*line :1994:10*/_Ctype_jfloatArray /*line :1994:23*/ = 0
	_ = x12
	var x13  /*line :1996:10*/_Ctype_jdoubleArray /*line :1996:24*/ = 0
	_ = x13
	var x14  /*line :1998:10*/_Ctype_jobjectArray /*line :1998:24*/ = 0
	_ = x14
	var x15  /*line :2000:10*/_Ctype_jweak /*line :2000:17*/ = 0
	_ = x15
}

// issue 22958
// Nothing to run, just make sure this compiles.
var Vissue22958  /*line :2006:17*/_Ctype_issue22958Type /*line :2006:33*/

func test23356(t *testing.T) {
	if got, want := ( /*line :2009:18*/_Cfunc_a /*line :2009:20*/)(),  /*line :2009:25*/_Ctype_int /*line :2009:30*/(5); got != want {
		t.Errorf("C.a() == %v, expected %v", got, want)
	}
	if got, want := ( /*line :2012:18*/_Cfunc_r /*line :2012:20*/)(),  /*line :2012:25*/_Ctype_int /*line :2012:30*/(3); got != want {
		t.Errorf("C.r() == %v, expected %v", got, want)
	}
}

// issue 23720

func Issue23720F() {
	var x  /*line :2020:8*/_Ctype_issue23720A /*line :2020:21*/
	( /*line :2021:2*/_Cfunc_issue23720F /*line :2021:14*/)(x)
}

// issue 24206

func test24206(t *testing.T) {
	if runtime.GOOS != "linux" || runtime.GOARCH != "amd64" {
		t.Skipf("skipping on %s/%s", runtime.GOOS, runtime.GOARCH)
	}

	if l := len(( /*line :2031:14*/_Cfunc_GoString /*line :2031:23*/)(( /*line :2031:25*/_Cfunc_dangerousString1 /*line :2031:42*/)())); l != 123 {
		t.Errorf("Incorrect string length - got %d, want 123", l)
	}
	if l := len(( /*line :2034:14*/_Cfunc_GoString /*line :2034:23*/)(( /*line :2034:25*/_Cfunc_dangerousString2 /*line :2034:42*/)())); l != 4096+123 {
		t.Errorf("Incorrect string length - got %d, want %d", l, 4096+123)
	}
}

// issue 25143

func issue25143sum(ns ... /*line :2041:26*/_Ctype_int /*line :2041:31*/)  /*line :2041:33*/_Ctype_int /*line :2041:38*/ {
	total :=  /*line :2042:11*/_Ctype_int /*line :2042:16*/(0)
	for _, n := range ns {
		total += n
	}
	return total
}

func test25143(t *testing.T) {
	if got, want := issue25143sum(1, 2, 3),  /*line :2050:42*/_Ctype_int /*line :2050:47*/(6); got != want {
		t.Errorf("issue25143sum(1, 2, 3) == %v, expected %v", got, want)
	}
}

// issue 26066
// Wrong type of constant with GCC 8 and newer.

func test26066(t *testing.T) {
	var i = int64(( /*line :2059:16*/*_Cvar_issue26066 /*line :2059:27*/))
	if i != -1 {
		t.Errorf("got %d, want -1", i)
	}
}

// issue 26517
var a  /*line :2066:7*/_Ctype_TypeOne /*line :2066:16*/
var b  /*line :2067:7*/_Ctype_TypeTwo /*line :2067:16*/

// issue 27660
// Stress the interaction between the race detector and cgo in an
// attempt to reproduce the memory corruption described in #27660.
// The bug was very timing sensitive; at the time of writing this
// test would only trigger the bug about once out of every five runs.

func test27660(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	ints := make([]int, 100)
	locks := make([]sync.Mutex, 100)
	// Slowly create threads so that ThreadSanitizer is forced to
	// frequently resize its SyncClocks.
	for i := 0; i < 100; i++ {
		go func() {
			for ctx.Err() == nil {
				// Sleep in C for long enough that it is likely that the runtime
				// will retake this goroutine's currently wired P.
				( /*line :2087:5*/_Cfunc_usleep /*line :2087:12*/)(1000 /* 1ms */)
				runtime.Gosched() // avoid starvation (see #28701)
			}
		}()
		go func() {
			// Trigger lots of synchronization and memory reads/writes to
			// increase the likelihood that the race described in #27660
			// results in corruption of ThreadSanitizer's internal state
			// and thus an assertion failure or segfault.
			i := 0
			for ctx.Err() == nil {
				j := rand.Intn(100)
				locks[j].Lock()
				ints[j]++
				locks[j].Unlock()
				// needed for gccgo, to avoid creation of an
				// unpreemptible "fast path" in this loop. Choice
				// of (1<<24) is somewhat arbitrary.
				if i%(1<<24) == 0 {
					runtime.Gosched()
				}
				i++

			}
		}()
		time.Sleep(time.Millisecond)
	}
}

// issue 28540

func twoargsF() {
	v := []string{}
	func() { _cgo0 := _Cfunc_twoargs2 /*line :2120:23*/(); var _cgo1 _Ctype_int = func() _Ctype_int{ _cgoBase0 := /*line :2120:53*/&v; _cgo0 := /*line :2120:38*/unsafe.Pointer(_cgoBase0); _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :2120:57*/_Cfunc_twoargs3(_cgo0); }(); _cgoCheckPointer(_cgo0, nil); /*line :2120:58*/_Cfunc_twoargs1(_cgo0, _cgo1); }()
}

// issue 28545

func issue28545G(p ** /*line :2125:22*/_Ctype_char /*line :2125:28*/) {
	func() { _cgo0 := /*line :2126:16*/p; var _cgo1 _Ctype_int = /*line :2126:19*/-1; var _cgo2 _Ctype_complexdouble = /*line :2126:23*/(0); _cgoCheckPointer(_cgo0, nil); /*line :2126:27*/_Cfunc_issue28545F(_cgo0, _cgo1, _cgo2); }()
	func() { _cgo0 := /*line :2127:16*/p; var _cgo1 _Ctype_int = /*line :2127:19*/2 + 3; var _cgo2 _Ctype_complexdouble = /*line :2127:24*/complex(1, 1); _cgoCheckPointer(_cgo0, nil); /*line :2127:38*/_Cfunc_issue28545F(_cgo0, _cgo1, _cgo2); }()
	func() { _cgo0 := /*line :2128:16*/p; var _cgo1 _Ctype_int = /*line :2128:19*/issue28772Constant; var _cgo2 _Ctype_complexdouble = /*line :2128:39*/issue28772Constant2; _cgoCheckPointer(_cgo0, nil); /*line :2128:59*/_Cfunc_issue28545F(_cgo0, _cgo1, _cgo2); }()
}

// issue 28772 part 1 - part 2 in testx.go

const issue28772Constant = ( /*line :2133:28*/_Ciconst_issue28772Constant /*line :2133:47*/)

// issue 28896

func offset(i int) uintptr {
	var pi  /*line :2138:9*/_Ctype_innerPacked /*line :2138:22*/
	var po  /*line :2139:9*/_Ctype_outerPacked /*line :2139:22*/
	var ui  /*line :2140:9*/_Ctype_innerUnpacked /*line :2140:24*/
	var uo  /*line :2141:9*/_Ctype_outerUnpacked /*line :2141:24*/
	switch i {
	case 0:
		return unsafe.Offsetof(pi.f2)
	case 1:
		return unsafe.Offsetof(po.g2)
	case 2:
		return unsafe.Offsetof(ui.f2)
	case 3:
		return unsafe.Offsetof(uo.g2)
	default:
		panic("can't happen")
	}
}

func test28896(t *testing.T) {
	for i := 0; i < 4; i++ {
		c := uintptr(( /*line :2158:16*/_Cfunc_offset /*line :2158:23*/)( /*line :2158:25*/_Ctype_int /*line :2158:30*/(i)))
		g := offset(i)
		if c != g {
			t.Errorf("%d: C: %d != Go %d", i, c, g)
		}
	}
}

// issue 29383
// cgo's /*line*/ comments failed when inserted after '/',
// because the result looked like a "//" comment.
// No runtime test; just make sure it compiles.

func Issue29383(n, size uint) int {
	if ^ /*line :2172:6*/_Ctype_size_t /*line :2172:14*/(0)/ /*line :2172:18*/_Ctype_size_t /*line :2172:26*/(n) <  /*line :2172:32*/_Ctype_size_t /*line :2172:40*/(size) {
		return 0
	}
	return 0
}

// issue 29748
// Error handling a struct initializer that requires pointer checking.
// Compilation test only, nothing to run.

var Vissue29748 = func() _Ctype_int{ _cgoBase0 := /*line :2182:28*/&_Ctype_S29748 /*line :2182:37*/{	nil,}; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :2184:3*/_Cfunc_f29748(_cgo0); }()

func Fissue299748() {
	func() _Ctype_int{ _cgoBase0 := /*line :2187:11*/&_Ctype_S29748 /*line :2187:20*/{	nil,}; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :2189:4*/_Cfunc_f29748(_cgo0); }()
}

// issue 29781

var issue29781X struct{ X int }

func issue29781F(...int) int { return 0 }

func issue29781G() {
	var p * /*line :2199:9*/_Ctype_char /*line :2199:15*/
	func() { _cgoBase0 := /*line :2200:16*/&p; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = _Ciconst_ISSUE29781C /*line :2200:33*/ + 	1; _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :2200:36*/_Cfunc_issue29781F(_cgo0, _cgo1); }()
	( /*line :2201:2*/_Cfunc_issue29781F /*line :2201:14*/)(nil, ( /*line :2201:22*/_Ctype_int /*line :2201:27*/)(
		0))
	func() { _cgoBase0 := /*line :2203:16*/&p; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = /*line :2203:20*/(_Ctype_int /*line :2203:26*/)(0); _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :2203:31*/_Cfunc_issue29781F(_cgo0, _cgo1); }()
	func() { _cgoBase0 := /*line :2204:16*/&p; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = /*line :2204:20*/(_Ctype_int /*line :2204:26*/)(	0); _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :2205:6*/_Cfunc_issue29781F(_cgo0, _cgo1); }()
	func() { _cgoBase0 := /*line :2206:16*/&p; _cgo0 := _cgoBase0; var _cgo1 _Ctype_int = /*line :2206:20*/(_Ctype_int /*line :2206:26*/)(issue29781X. 	X); _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :2207:6*/_Cfunc_issue29781F(_cgo0, _cgo1); }()
}

// issue 30065

func test30065(t *testing.T) {
	var a [256]byte
	b := []byte("a")
	func() _cgo_unsafe.Pointer{ _cgoBase0 := /*line :2215:26*/&a; _cgo0 := /*line :2215:11*/unsafe.Pointer(_cgoBase0); _cgoIndex1 := &/*line :2215:47*/b; _cgo1 := /*line :2215:31*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = /*line :2215:54*/1; _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :2215:56*/_Cfunc_memcpy(_cgo0, _cgo1, _cgo2); }()
	if a[0] != 'a' {
		t.Errorf("&a failed: got %c, want %c", a[0], 'a')
	}

	b = []byte("b")
	func() _cgo_unsafe.Pointer{ _cgoIndex0 := &/*line :2221:27*/a; _cgo0 := /*line :2221:11*/unsafe.Pointer(&(*_cgoIndex0)[0]); _cgoIndex1 := &/*line :2221:50*/b; _cgo1 := /*line :2221:34*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = /*line :2221:57*/1; _cgoCheckPointer(_cgo0, *_cgoIndex0); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :2221:59*/_Cfunc_memcpy(_cgo0, _cgo1, _cgo2); }()
	if a[0] != 'b' {
		t.Errorf("&a[0] failed: got %c, want %c", a[0], 'b')
	}

	d := make([]byte, 256)
	b = []byte("c")
	func() _cgo_unsafe.Pointer{ _cgoIndex0 := &/*line :2228:27*/d; _cgo0 := /*line :2228:11*/unsafe.Pointer(&(*_cgoIndex0)[0]); _cgoIndex1 := &/*line :2228:50*/b; _cgo1 := /*line :2228:34*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = /*line :2228:57*/1; _cgoCheckPointer(_cgo0, *_cgoIndex0); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :2228:59*/_Cfunc_memcpy(_cgo0, _cgo1, _cgo2); }()
	if d[0] != 'c' {
		t.Errorf("&d[0] failed: got %c, want %c", d[0], 'c')
	}
}

// issue 31093
// No runtime test; just make sure it compiles.

func Issue31093() {
	( /*line :2238:2*/_Cfunc_issue31093F /*line :2238:14*/)( /*line :2238:16*/_Ctype_ushort /*line :2238:24*/(0))
}

// issue 32579

func test32579(t *testing.T) {
	var s [1] /*line :2244:11*/_Ctype_struct_S32579 /*line :2244:26*/
	func() _cgo_unsafe.Pointer{ _cgoIndex0 := &/*line :2245:27*/s[0].data; _cgo0 := /*line :2245:11*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :2245:42*/1; var _cgo2 _Ctype_size_t = /*line :2245:45*/1; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :2245:47*/_Cfunc_memset(_cgo0, _cgo1, _cgo2); }()
	if s[0].data[0] != 1 {
		t.Errorf("&s[0].data[0] failed: got %d, want %d", s[0].data[0], 1)
	}
}

// issue 37033, check if cgo.Handle works properly

func testHandle(t *testing.T) {
	ch := make(chan int)

	for i := 0; i < 42; i++ {
		h := cgo.NewHandle(ch)
		go func() {
			( /*line :2259:4*/_Cfunc_cFunc37033 /*line :2259:15*/)( /*line :2259:17*/_Ctype_uintptr_t /*line :2259:28*/(h))
		}()
		if v := <-ch; issue37033 != v {
			t.Fatalf("unexpected receiving value: got %d, want %d", v, issue37033)
		}
		h.Delete()
	}
}

// issue 38649

var issue38649  /*line :2270:16*/_Ctype_netbsd_gid /*line :2270:28*/ = 42

// issue 39877

var issue39877 * /*line :2274:17*/_Ctype_void /*line :2274:23*/ = nil

// issue 40494
// No runtime test; just make sure it compiles.

func Issue40494() {
	( /*line :2280:2*/_Cfunc_issue40494 /*line :2280:13*/)( /*line :2280:15*/_Ctype_enum_Enum40494 /*line :2280:31*/(( /*line :2280:32*/_Ciconst_X_40494 /*line :2280:40*/)), (* /*line :2280:46*/_Ctype_union_Union40494 /*line :2280:64*/)(nil))
}

// Issue 45451.
func test45451(t *testing.T) {
	var u * /*line :2285:9*/_Ctype_issue45451 /*line :2285:21*/
	typ := reflect.ValueOf(u).Type().Elem()

	// The type is undefined in C so allocating it should panic.
	defer func() {
		if r := recover(); r == nil {
			t.Error("expected panic")
		}
	}()

	_ = reflect.New(typ)
	t.Errorf("reflect.New(%v) should have panicked", typ)
}

// issue 52542

func func52542[T ~[] /*line :2301:21*/_Ctype_int /*line :2301:26*/]() {}

type type52542[T ~* /*line :2303:20*/_Ctype_float /*line :2303:27*/] struct{}
