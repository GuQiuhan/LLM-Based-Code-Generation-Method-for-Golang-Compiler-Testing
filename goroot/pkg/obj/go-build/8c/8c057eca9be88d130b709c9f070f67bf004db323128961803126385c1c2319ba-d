# example.com/pgo/inline [example.com/pgo/inline.test]
./inline_hot.go:24:6: can inline D with cost 7 as: func(uint) int { return int((i + (wSize - 1)) >> lWSize) }
./inline_hot.go:28:6: can inline N with cost 20 as: func(uint) *BS { bs = &BS{...}; return bs }
./inline_hot.go:31:19: inlining call to D
./inline_hot.go:37:6: can inline (*BS).S with cost 14 as: method(*BS) func(uint) *BS { b.s[i >> lWSize] |= 1 << (i & (wSize - 1)); return b }
./inline_hot.go:49:6: can inline T with cost 12 as: func(uint64) uint { return uint(jn[v & -v * 0x03f79d71b4ca8b09 >> 58]) }
./inline_hot.go:53:6: can inline (*BS).NS with cost 106 as: method(*BS) func(uint) (uint, bool) { x := int(i >> lWSize); if x >= len(b.s) { return 0, false }; w := b.s[x]; w = w >> (i & (wSize - 1)); if w != 0 { return i + T(w), true }; x = x + 1; for loop; return 0, false }
./inline_hot.go:61:15: inlining call to T
./inline_hot.go:66:28: inlining call to T
./inline_hot.go:74:6: cannot inline A: function too complex: cost 312 exceeds budget 80
./inline_hot.go:75:8: inlining call to N
./inline_hot.go:77:6: inlining call to (*BS).S
./inline_hot.go:81:19: inlining call to (*BS).NS
./inline_hot.go:81:38: inlining call to (*BS).NS
./inline_hot.go:75:8: inlining call to D
./inline_hot.go:81:19: inlining call to T
./inline_hot.go:81:19: inlining call to T
./inline_hot.go:81:38: inlining call to T
./inline_hot.go:81:38: inlining call to T
./inline_hot.go:87:6: cannot inline main: function too complex: cost 119 exceeds budget 80
./inline_hot_test.go:17:6: cannot inline benchmarkB: function too complex: cost 427 exceeds budget 80
./inline_hot_test.go:14:6: can inline BenchmarkA with cost 60 as: func(*testing.B) { benchmarkB(b) }
./inline_hot.go:31:7: make([]uint64, ~R0) escapes to heap:
./inline_hot.go:31:7:   flow: {heap} = &{storage for make([]uint64, ~R0)}:
./inline_hot.go:31:7:     from make([]uint64, ~R0) (non-constant size) at ./inline_hot.go:31:7
./inline_hot.go:29:7: &BS{...} escapes to heap:
./inline_hot.go:29:7:   flow: bs = &{storage for &BS{...}}:
./inline_hot.go:29:7:     from &BS{...} (spill) at ./inline_hot.go:29:7
./inline_hot.go:29:7:     from bs = &BS{...} (assign) at ./inline_hot.go:29:5
./inline_hot.go:29:7: &BS{...} escapes to heap
./inline_hot.go:31:7: make([]uint64, ~R0) escapes to heap
./inline_hot.go:37:7: parameter b leaks to ~r0 with derefs=0:
./inline_hot.go:37:7:   flow: ~r0 = b:
./inline_hot.go:37:7:     from return b (return) at ./inline_hot.go:39:2
./inline_hot.go:37:7: leaking param: b to result ~r0 level=0
./inline_hot.go:53:7: b does not escape
./inline_hot.go:75:8: make([]uint64, ~R0) escapes to heap:
./inline_hot.go:75:8:   flow: {heap} = &{storage for make([]uint64, ~R0)}:
./inline_hot.go:75:8:     from make([]uint64, ~R0) (non-constant size) at ./inline_hot.go:75:8
./inline_hot.go:75:8: &BS{...} does not escape
./inline_hot.go:75:8: make([]uint64, ~R0) escapes to heap
./inline_hot_test.go:17:17: b does not escape
./inline_hot_test.go:14:17: b does not escape
./inline_hot.go:50:16: index bounds check elided
./inline_hot.go:61:15: index bounds check elided
./inline_hot.go:66:28: index bounds check elided
./inline_hot.go:81:19: index bounds check elided
./inline_hot.go:81:19: index bounds check elided
./inline_hot.go:81:38: index bounds check elided
./inline_hot.go:81:38: index bounds check elided
