{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr:= bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\nvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReaBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _,err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FieExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package s\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadByesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytsFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadByteFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error){\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\nfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err!= nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err !=nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\rfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\nbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts,_, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err!= nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err !=nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FleExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FilExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string)bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\nif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err:= os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBtesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\nif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil,err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc RedLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReaLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLins(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLine(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string{\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres= append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExits(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor{\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc ileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool{\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res[]string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err:= br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\rfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc RadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFomFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFrmFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFroFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err:= os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err :=os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil{\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\nreturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLies(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader)[]string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\rfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileEists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _,err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\rimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport(\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc eadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFle(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFie(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string)([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin,err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc eadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc RadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLnes(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr :=bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\nfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil{\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres =append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc Filexists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExsts(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExist(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err :=os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package k\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc RedBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFil(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte,error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc Readines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err :=br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res,string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExiss(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter s","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn k","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder s","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\tretu","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) ","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = appen","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\t","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\tretur","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...inter","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logge","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc ","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\tretur","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interf","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn re","output":""}
{"input":"ackage apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Pan","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(arg","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n","output":""}
{"input":"pckage apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...","output":""}
{"input":"ackage ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"pckage ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"pakage apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r","output":""}
{"input":"pacage apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n","output":""}
{"input":"packge apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"ackage protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"pakage ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"pacage ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"packae apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"packge ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"pckage protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"pakage protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"packag apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"packae ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"packageapimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"pacage protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package pimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"packag ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"packge protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"packae protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package aimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"packageks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apmgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"packag protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"packageprotolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apigr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package rotolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package potolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimg\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package prtolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package proolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\rimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nmport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\niport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimort \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimprt \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protlog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimpot \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimpor \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport\"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protoog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"eflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolg \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"rflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"relect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLogi","output":""}
{"input":"package ks\r\n\r\nmport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolo \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"refect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflct\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog\r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\niport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflet\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimort (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) D","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflec\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimprt (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimpot (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\rimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimpor (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServ","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\rfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfnc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nmport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != n","output":""}
{"input":"package protolog \r\n\r\niport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport \r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfuc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = pa","output":""}
{"input":"package protolog \r\n\r\nimort (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimprt (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfun newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimpot (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfuncnewSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\tbufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimpor (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc ewSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport(\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"ufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginS","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc nwSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport \r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bfio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\tr","output":""}
{"input":"package protolog \r\n\r\nimport (\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"buio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufo\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\tretur","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc neSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufi\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\tos\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc neworter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"s\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"o\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\tfmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"mt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"ft\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"ackage minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fm\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"pckage minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"pakage minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\tio\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"o\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"i\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\tgo.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"pacage minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"o.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"g.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"packge minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\tio/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"o/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"gopedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"i/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"packae minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"ioioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.edge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSrter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSoter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pdge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/outil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorer(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pege.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSortr(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorte(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/iutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pede.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSortermanager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/iotil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedg.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(anager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedgeio/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/iouil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(mnager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.o/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutl\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(maager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manger *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.i/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manaer *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(managr *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/iouti\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.iodlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manage *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/log\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager*Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"packag minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *anager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlg\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Mnager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlo\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"packageminecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Maager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\tos\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package inecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"s\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manger) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"o\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package mnecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manaer) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Managr) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\tgo.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manage) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"o.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package miecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"g.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager)*sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"gopedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *orter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package mincraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *srter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.edge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pdge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\tpath/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pege.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"ath/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"pth/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pede.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"pah/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *soter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedg.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"pat/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"pathfilepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedgeio/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/ilepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.o/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/flepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorer {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/fiepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.i/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filpath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.ioprotolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/fileath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepth\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sortr {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepah\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/rotolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package mineraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepat\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/potolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecaft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorte {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/prtolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter{\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/proolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protlog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter \r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protoog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolg\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecrft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\napis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolo\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tpis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tais := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecrat\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\taps := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapi := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis:= []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis = []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraf\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis : []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis :=[]Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\rfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := ]Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := [Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfnc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfuc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfnc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfun ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []efinition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfuncReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfuc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfun init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Dfinition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfuncinit() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc nit() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Deinition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc iit() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc int() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Defnition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc ini() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFilefilename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init) {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(ilename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(flename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init( {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(fiename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Defiition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filname string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init(){\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(fileame string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filenme string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() \r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filenae string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filenam string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filenamestring) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Defintion{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename tring) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename sring) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\ndlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename sting) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definiion{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename strng) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename strig) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename strin) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definiton{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlg.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) []byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) (]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlo.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definitin{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlogSetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]yte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.etLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definitio{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.StLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]bte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SeLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]bye, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.Setogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byt, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLgger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLoger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLoggr(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogge(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, rror) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLoggerNewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\nfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, eror) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(ewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\rimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NwLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NeLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, errr) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(Newogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfr _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, erro) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfo _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLgger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nmport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor_, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLoger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor , api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) \r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLoggr(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogge(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _ api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLoggerprotolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(rotolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\niport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _,api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(potolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, pi := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, ai := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(prtolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfn, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, ap := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api:= range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api = range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimort (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfi, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api : range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(proolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api :=range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := ange manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := rnge manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := rage manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protlog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := rane manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimprt (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protoog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := rang manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolg.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, rr := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolo.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, er := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimpot (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protologNewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.ewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err = os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NwStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := rangemanager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err : os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NeStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimpor (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range anager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewtandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range mnager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport(\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewSandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := s.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range maager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport \r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := o.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStndardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manger.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := osOpen(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manaer.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.pen(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStadardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Oen(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStanardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range managr.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Opn(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandrdLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Ope(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Openfilename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandadLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manage.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(ilename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(flename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandarLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(fiename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filname)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range managerapiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(fileame)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLgger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filenme)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.piMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filenae)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filenam)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLoger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.aiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLoggr(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogge(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLoggerprotolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tf err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\ti err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(rotolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tiferr != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(potolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif rr != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif er != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMthodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(prtolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(proolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err = nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protlog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err ! nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protoog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != il {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolg.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMehodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nl {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolo.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMetodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != ni {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\tio\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protologNewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil \r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.ewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethdPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NwFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NeFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethoPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFleFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\teturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFieFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\trturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treurn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\tretrn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFilFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\tretun nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFilelusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\tretur nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturnnil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn il, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlsher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nl, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPtternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn ni, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFluher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFluser(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlushr(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, rr\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPaternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, er\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlushe(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusheros.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(s.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(o.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(osStderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPattrnMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.tderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"o\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Sderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\teturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPattenMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\trturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"i\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Sterr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatterMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treurn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tretrn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stdrr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tretun ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMp {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stder))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tretur ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMa {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturnioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap{\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr)))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn outil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap \r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn iutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn iotil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn iouil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutl.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn iouti.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tpis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutilReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tais = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.eadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\tgithub.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.RadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\taps = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapi = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis= append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis  append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.RedAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis =append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = ppend(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = apend(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReaAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = appnd(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = apped(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\rtype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = appen(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = appendapis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(pis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\nype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(ais, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.Readll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(aps, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(api, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"ithub.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAl(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntpe logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis,api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, pi)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, ai)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntye logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, ap)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntyp logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntypelogger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAllfin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype ogger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\nreturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(in)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\teturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fn)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\trturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treurn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\tretrn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype lgger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"gthub.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\tretun \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fi)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\tretur \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"gihub.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype loger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn\u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype loggr struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"gitub.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026orter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logge struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"githb.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026srter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype loggerstruct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026soter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger truct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorer{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger sruct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sortr{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger stuct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorte{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"githu.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfnc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger strct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger strut {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfuc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struc {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfun ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfuncReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"githubcom/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct{\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct \r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.om/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tanager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\nprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tMnager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.cm/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\trotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tMaager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tpotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManger: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.co/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprtolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManaer: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tproolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManagr: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.comLilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotlog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManage: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLinesr io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/ilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotoog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines( io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager:manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(rio.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolg.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: anager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r o.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolo.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: mnager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r i.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LlyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotologLogger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: maager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r ioReader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.ogger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.eader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manger,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Lgger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LiyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Loger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Rader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manaer,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reder) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Loggr\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: managr,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reaer) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manage,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logge\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Readr) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reade) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/Lilyad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPd/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tpis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tais:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) ]string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\taps:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) [string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []tring {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPa/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapi:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []sring {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []sting {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:   apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\rfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPadGoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfnc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    pis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/oLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    ais,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfuc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfun NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    aps,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    api,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfuncNewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc ewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []strng {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NwLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []strig {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []strin {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLlyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NeLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLiyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string \r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc Newogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLgger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLoger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLoggr(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogge(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\rtype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLoggerl protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPd/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger( protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\nype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(lprotolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tb := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l rotolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l potolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l prtolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr = bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntpe sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr : bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l proolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := ufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protlog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bfio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntye sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protoog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := buio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolg.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufo.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntyp sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolo.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufi.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufioNewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protologLogger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.ewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntypesorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NwReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.ogger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype orter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Lgger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPa/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NeReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Loger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.Neweader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPadpacket\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype srter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewRader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype soter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReder(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Loggr) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorer struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logge) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/acket\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReaer(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sortr struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger)dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReadr(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorte struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) log.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/pcket\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReade(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorterstruct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter truct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReaderr)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter sruct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlg.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader()\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlo.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter stuct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/paket\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlogLogger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter strct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter strut {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.ogger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struc {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Lgger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/pacet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct{\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct \r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Loger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Loggr {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packt\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logge {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\tManager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*anager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvr res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger{\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Mnager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packe\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tva res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger \r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Maager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manger\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvarres []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manaer\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar es []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Managr\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar rs []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manage\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar re []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\nreturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\teturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res ]string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\trturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treurn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\napis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res [string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []tring\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\tretrn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tpis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []sring\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\tretun \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\tretur \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn\u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []sting\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tais []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []strng\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []strig\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026ogger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\taps []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []strin\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026lgger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026loger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026loggr{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapi []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logge{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026loggerl}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis[]Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfr {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis ]Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfo {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis [Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor \r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\rtype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []efinition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Dfinition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\nype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Deinition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntpe PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\t, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Defnition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntye PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Defiition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntyp PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Defintion\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntypePacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definiion\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, , err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definiton\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype acketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _ err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definitin\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PcketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definitio\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PaketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, rr := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, er := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacetServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacktServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PackeServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err = br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err : br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketerverLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\rfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketSrverLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfnc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := r.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfuc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketSeverLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfun (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := b.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc(l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketSererLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := brReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc ( *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\rfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfnc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l*logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServrLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfuc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfun (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc(t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *ogger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *lgger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc ( sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (tsorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.eadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t orter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServeLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t srter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *loger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t soter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.RadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorer) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServeroginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sortr) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorte) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter)Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.RedLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) wap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Sap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReaLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *loggr) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swp(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swa(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swapi int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.Readine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logge) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap( int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(iint, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i nt, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger)Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLne()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i it, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) ebug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i in, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoinStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLie()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Dbug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLin()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int,j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int,  int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Deug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, jint) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine)\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j nt) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLognStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine(\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debg(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j it) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debu(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLogiStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j in) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debugargs ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(rgs ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLogintart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(ags ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int){\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(ars ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) \r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginSart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(arg ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\nt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStrt struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\t.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tf err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\ttapis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\ti err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ..interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.pis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tiferr != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.ais[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif rr != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStat struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.aps[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif er != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.api[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...nterface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStar struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...iterface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apisi], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStartstruct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err = nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err ! nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...inerface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i, t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != il {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...intrface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i] t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...inteface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nl {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i],t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interace{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != ni {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interfce{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart truct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], .apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], tapis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interfae{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil \r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart sruct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interfac{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.pis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.ais[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart stuct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.aps[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.api[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart strct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{} {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apisj] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\teturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}){\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\trturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart strut {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treurn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) \r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j]= t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\tretrn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j]  t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\tretun res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struc {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] =t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\tretur res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = .apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\nl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturnres\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct{\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = tapis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn es\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\t.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.pis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.ais[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tlDebugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct \r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn rs\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.ebugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.aps[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Dbugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn re\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.api[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apisj], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Deugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debgln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j, t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debuln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j] t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugn(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugl(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j],t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\nName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], .apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debuglnargs...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], tapis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(rgs...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.pis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tame string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(ags...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.ais[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(ars...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.aps[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(arg...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args..)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.api[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tNme string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tes = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apisi]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\trs = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tNae string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tre = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tNam string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres  append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = ppend(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\rfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = apend(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tNamestring\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfnc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfuc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName tring\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfun (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = appnd(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\rfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc(l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = apped(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName sring\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = appen(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfnc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc ( *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = appendres, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfuc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l*logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(es, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfun (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName sting\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(rs, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *ogger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc(t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(re, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *lgger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc ( sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *loger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (tsorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, tring(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *loggr) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t orter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logge) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t srter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName strng\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, sring(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger)Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t soter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorer) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) nfo(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, sting(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Ifo(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sortr) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, strng(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorte) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Ino(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName strig\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, strig(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName strin\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Inf(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, strin(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\n}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter)Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Infoargs ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, strings))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) ess(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r}\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string())\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(rgs ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n\r\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Lss(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(ags ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s)\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\n\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(ars ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Les(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(arg ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ..interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Lessi int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\r\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less( int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(iint, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...nterface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...iterface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i nt, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...inerface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i it, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...intrface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\rfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...inteface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i in, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interace{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interfce{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int,j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interfae{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int,  int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfnc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interfac{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, jint) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j nt) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j it) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j in) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{} {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfuc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int)bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}){\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) \r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) ool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bol {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfun NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) boo {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool{\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\nl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool \r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\t.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfuncNewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\nki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nunc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tlInfoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\ti := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.nfoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfnc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tk := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki:= t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfuc FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Ifoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki = t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfun FileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki : t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki :=t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc ewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfuncFileExists(filename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Inoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := .getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := tgetSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.etSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.gtSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.geSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NwPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSrtKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSotKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infon(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSorKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infol(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKy(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NePacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infolnargs...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKe(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKeyt.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewacketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(rgs...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(tapis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.pis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(ags...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPcketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(ars...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.ais[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.aps[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(arg...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.api[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apisi])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPaketServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i)\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args..)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i]\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExistsfilename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\nkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(ilename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacetServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tk := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(flename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj:= t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(fiename string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj = t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacktServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj : t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj :=t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := .getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := tgetSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filname string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.etSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPackeServerLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.gtSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.geSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(fileame string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\n}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filenme string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketerverLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filenae string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSrtKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r}\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filenam string) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSotKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n\r\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filenamestring) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSorKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename tring) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKy(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketSrverLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\n\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKe(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketSeverLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename sring) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\r\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketSererLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename sting) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKeyt.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServrLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename strng) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\nfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename strig) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServeLoginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServeroginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\rfunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(tapis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename strin) bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLginStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.pis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nunc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoinStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string bool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfnc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLognStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfuc (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfun (l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) ool {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.ais[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLogiStart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bol {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc(l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.aps[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc l *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLogintart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc ( *logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.api[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) boo {\r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apisj])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginSart(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l*logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStrt(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool \r\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStat(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l logger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j)\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *ogger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j]\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *lgger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\nreturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStar(name string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\teturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *loger) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tf _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\trturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treurn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *loggr) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\tretrn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logge) Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\tretun ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStartname string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\tretur ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturnki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\ti _, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn i \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(ame string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger)Warn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn k \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) arn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki\u003c kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki  kj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Wrn(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003ckj\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(nme string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c j\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Wan(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) War(args ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c k\r\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\n}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warnargs ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r}\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n\r\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif_, err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(rgs ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\n\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(nae string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(ags ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\r\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\nfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\rfunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(ars ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(arg ...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nunc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(nam string) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args...interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfnc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfuc (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ..interface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfun (t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc(t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif , err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(namestring) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc t sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc ( sorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _ err := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...nterface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (tsorter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t orter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...iterface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...inerface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t srter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t soter) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...intrface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorer) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name tring) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...inteface{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sortr) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, rr := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorte) getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, er := os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interace{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name sring) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interfce{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter)getSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interfae{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) etSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err = os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) gtSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interfac{}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err : os.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) geSortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package protolog \r\n\r\nimport (\r\n\t\"os\"\r\n\r\n\t\"go.pedge.io/dlog\"\r\n\t\"go.pedge.io/protolog\"\r\n)\r\n\r\nfunc init() {\r\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\r\n}\r\n\r\ntype logger struct {\r\n\tprotolog.Logger\r\n}\r\n\r\n\r\nfunc NewLogger(l protolog.Logger) dlog.Logger {\r\n\treturn \u0026logger{l}\r\n}\r\n\r\nfunc (l *logger) Debug(args ...interface{}) {\r\n\tl.Debugln(args...)\r\n}\r\n\r\nfunc (l *logger) Info(args ...interface{}) {\r\n\tl.Infoln(args...)\r\n}\r\n\r\nfunc (l *logger) Warn(args ...interface}) {\r\n\tl.Warnln(args...)\r\n}\r\n\r\nfunc (l *logger) Error(args ...interface{}) {\r\n\tl.Errorln(args...)\r\n}\r\n\r\nfunc (l *logger) Fatal(args ...interface{}) {\r\n\tl.Fatalln(args...)\r\n}\r\n\r\n\r\n\r\nfunc (l *logger) Print(args ...interface{}) {\r\n\tl.Println(args...)\r\n}\r\n\r\nfunc (l *logger) Panic(args ...interface{}) {\r\n\tl.Panicln(args...)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getortKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSrtKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}
{"input":"package minecraft\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"github.com/LilyPad/GoLilyPad/packet\"\r\n)\r\n\r\ntype PacketServerLoginStart struct {\r\n\tName string\r\n}\r\n\r\nfunc NewPacketServerLoginStart(name sting) (this *PacketServerLoginStart) {\r\n\tthis = new(PacketServerLoginStart)\r\n\tthis.Name = name\r\n\treturn\r\n}\r\n\r\nfunc (this *PacketServerLoginStart) Id() int {\r\n\treturn PACKET_SERVER_LOGIN_START\r\n}\r\n\r\ntype packetServerLoginStartCodec struct {\r\n\r\n}\r\n\r\n\r\n\r\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\r\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\r\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\r\n\treturn\r\n}\r\n\r\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\r\n\tpacketServerLoginStart := new(PacketServerLoginStart)\r\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tdecode = packetServerLoginStart\r\n\treturn\r\n}","output":""}
{"input":"package ks\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n)\r\n\r\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\r\n\tfin, err := os.Open(filename)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn ioutil.ReadAll(fin)\r\n}\r\n\r\nfunc ReadLines(r io.Reader) []string {\r\n\r\n\tbr := bufio.NewReader(r)\r\n\tvar res []string\r\n\r\n\tfor {\r\n\t\ts, _, err := br.ReadLine()\r\n\r\n\t\tif err != nil {\r\n\t\t\treturn res\r\n\t\t}\r\n\r\n\t\tres = append(res, string(s))\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunc FileExists(filename string) bool {\r\n\tif _, err := s.Stat(filename); os.IsNotExist(err) {\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc ListFiles(folder string) []string {\r\n\r\n\tvar res []string\r\n\r\n\tfilepath.Walk(fmt.Sprintf(folder),\r\n\t\tfunc(path string, info os.FileInfo, err error) error {\r\n\r\n\t\t\tif info != nil \u0026\u0026 !info.IsDir() {\r\n\t\t\t\tres = append(res, info.Name())\r\n\t\t\t}\r\n\r\n\t\t\treturn nil\r\n\t\t})\r\n\treturn res\r\n}","output":""}
{"input":"package apimgr\r\n\r\nimport \"reflect\"\r\n\r\nfunc newSorter(manager *Manager) *sorter {\r\n\tapis := []Definition{}\r\n\tfor _, api := range manager.apiMethodPatternMap {\r\n\t\tapis = append(apis, api)\r\n\t}\r\n\treturn \u0026sorter{\r\n\t\tManager: manager,\r\n\t\tapis:    apis,\r\n\t}\r\n}\r\n\r\ntype sorter struct {\r\n\t*Manager\r\n\r\n\tapis []Definition\r\n}\r\n\r\n\r\n\r\nfunc (t sorter) Swap(i int, j int) {\r\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\r\n}\r\n\r\nfunc (t sorter) Less(i int, j int) bool {\r\n\tki := t.getSortKey(t.apis[i])\r\n\tkj := t.getSortKey(t.apis[j])\r\n\treturn ki \u003c kj\r\n}\r\n\r\nfunc (t sorter) getSotKey(api Definition) string {\r\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\r\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\r\n\treturn key\r\n}\r\n\r\nfunc (t sorter) Len() int {\r\n\treturn len(t.apis)\r\n}","output":""}